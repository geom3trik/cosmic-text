<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Mapping complex text to a sequence of positioned glyphs."><meta name="keywords" content="rust, rustlang, rust-lang, shape"><title>swash::shape - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module shape</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../swash/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">swash</a>::<wbr><a class="mod" href="#">shape</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/swash/shape/mod.rs.html#1-913">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Mapping complex text to a sequence of positioned glyphs.</p>
<p>Shaping is the process of converting a sequence of
<a href="../text/cluster/struct.CharCluster.html">character clusters</a> into a sequence of
<a href="cluster/struct.GlyphCluster.html">glyph clusters</a> with respect to the rules of a particular
writing system and the typographic features available in a font. The shaper
operates on one <em>item</em> at a time where an item is a run of text with
a single script, language, direction, font, font size, and set of variation/feature
settings. The process of producing these runs is called <em>itemization</em>
and is out of scope for this crate.</p>
<h2 id="building-the-shaper"><a href="#building-the-shaper">Building the shaper</a></h2>
<p>All shaping in this crate takes place within the purview of a
<a href="struct.ShapeContext.html" title="ShapeContext"><code>ShapeContext</code></a>. This opaque struct manages internal LRU caches and scratch
buffers that are necessary for the shaping process. Generally, you’ll
want to keep an instance that persists for more than one layout pass as
this amortizes the cost of allocations, reduces contention for the global
heap and increases the hit rate for the internal acceleration structures. If
you’re doing multithreaded layout, you should keep a context per thread.</p>
<p>The only method available on the context is <a href="struct.ShapeContext.html#method.builder"><code>builder</code></a>
which takes a type that can be converted into a <a href="../struct.FontRef.html" title="FontRef"><code>FontRef</code></a> as an argument
and produces a <a href="struct.ShaperBuilder.html" title="ShaperBuilder"><code>ShaperBuilder</code></a> that provides options for configuring and
building a <a href="struct.Shaper.html" title="Shaper"><code>Shaper</code></a>.</p>
<p>Here, we’ll create a context and build a shaper for Arabic text at 16px:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ShapeContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>shaper = context.builder(font)
    .script(Script::Arabic)
    .direction(Direction::RightToLeft)
    .size(<span class="number">16.</span>)
    .build();</code></pre></div>
<p>You can specify feature settings by calling the <a href="struct.ShaperBuilder.html#method.features"><code>features</code></a>
method with an iterator that yields a sequence of values that are convertible
to <a href="../struct.Setting.html" title="Setting&lt;u16&gt;"><code>Setting&lt;u16&gt;</code></a>. Tuples of (&amp;str, u16) will work in a pinch. For example,
you can enable discretionary ligatures like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ShapeContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>shaper = context.builder(font)
    .script(Script::Latin)
    .size(<span class="number">14.</span>)
    .features(<span class="kw-2">&amp;</span>[(<span class="string">&quot;dlig&quot;</span>, <span class="number">1</span>)])
    .build();</code></pre></div>
<p>A value of <code>0</code> will disable a feature while a non-zero value will enable it.
Some features use non-zero values as an argument. The stylistic alternates
feature, for example, often offers a collection of choices per glyph. The argument
is used as an index to select among them. If a requested feature is not present
in a font, the setting is ignored.</p>
<p>Font variation settings are specified in a similar manner with the
<a href="struct.ShaperBuilder.html#method.variations"><code>variations</code></a> method but take an <code>f32</code>
to define the value within the variation space for the requested axis:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ShapeContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>shaper = context.builder(font)
    .script(Script::Latin)
    .size(<span class="number">14.</span>)
    .variations(<span class="kw-2">&amp;</span>[(<span class="string">&quot;wght&quot;</span>, <span class="number">520.5</span>)])
    .build();</code></pre></div>
<p>See <a href="struct.ShaperBuilder.html" title="ShaperBuilder"><code>ShaperBuilder</code></a> for available options and default values.</p>
<h2 id="feeding-the-shaper"><a href="#feeding-the-shaper">Feeding the shaper</a></h2>
<p>Once we have a properly configured shaper, we need to feed it some
clusters. The simplest approach is to call the <a href="struct.Shaper.html#method.add_str"><code>add_str</code></a>
method with a string:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>shaper.add_str(<span class="string">&quot;a quick brown fox?&quot;</span>);</code></pre></div>
<p>You can call <a href="struct.Shaper.html#method.add_str"><code>add_str</code></a> multiple times to add a sequence
of text fragments to the shaper.</p>
<p>This simple approach is certainly reasonable when dealing with text consisting
of a single run on one line with a font that is known to contain all the
necessary glyphs. A small text label in a UI is a good example.</p>
<p>For more complex scenarios, the shaper can be fed a single cluster at a time.
This method allows you to provide:</p>
<ul>
<li>accurate source ranges per character even if your runs
and items span multiple non-contiguous fragments</li>
<li>user data per character (a single <code>u32</code>) that can be used, for
example, to associate each resulting glyph with a style span</li>
<li>boundary analysis per character, carrying word boundaries and
line break opportunities through the shaper.</li>
</ul>
<p>This also provides a junction point for inserting a font fallback
mechanism.</p>
<p>All of this is served by the functionality in the
<a href="../text/cluster/index.html"><code>text::cluster</code></a> module.</p>
<p>Let’s see a somewhat contrived example that demonstrates the process:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>swash::text::cluster::{CharCluster, CharInfo, Parser, Token};
<span class="kw">let </span><span class="kw-2">mut </span>shaper = context.builder(font)
    .script(Script::Latin)
    .build();
<span class="comment">// We&#39;ll need the character map for our font
</span><span class="kw">let </span>charmap = font.charmap();
<span class="comment">// And some storage for the cluster we&#39;re working with
</span><span class="kw">let </span><span class="kw-2">mut </span>cluster = CharCluster::new();
<span class="comment">// Now we build a cluster parser which takes a script and
// an iterator that yields a Token per character
</span><span class="kw">let </span><span class="kw-2">mut </span>parser = Parser::new(
    Script::Latin,
    <span class="string">&quot;a quick brown fox?&quot;</span>.char_indices().map(|(i, ch)| Token {
        <span class="comment">// The character
        </span>ch,
        <span class="comment">// Offset of the character in code units
        </span>offset: i <span class="kw">as </span>u32,
        <span class="comment">// Length of the character in code units
        </span>len: ch.len_utf8() <span class="kw">as </span>u8,
        <span class="comment">// Character information
        </span>info: ch.into(),
        <span class="comment">// Pass through user data
        </span>data: <span class="number">0</span>,
    })
);
<span class="comment">// Loop over all of the clusters
</span><span class="kw">while </span>parser.next(<span class="kw-2">&amp;mut </span>cluster) {
    <span class="comment">// Map all of the characters in the cluster
    // to nominal glyph identifiers
    </span>cluster.map(|ch| charmap.map(ch));
    <span class="comment">// Add the cluster to the shaper
    </span>shaper.add_cluster(<span class="kw-2">&amp;</span>cluster);
}</code></pre></div>
<p>Phew! That’s quite a lot of work. It also happens to be exactly what
<a href="struct.Shaper.html#method.add_str"><code>add_str</code></a> does internally.</p>
<p>So why bother? As mentioned earlier, this method allows you to customize
the per-character data that passes through the shaper. Is your source text in
UTF-16 instead of UTF-8? No problem. Set the <a href="../text/cluster/struct.Token.html#structfield.offset"><code>offset</code></a> and
<a href="../text/cluster/struct.Token.html#structfield.len"><code>len</code></a> fields of your <a href="../text/cluster/struct.Token.html" title="Token"><code>Token</code></a>s to appropriate values. Are you shaping
across style spans? Set the <a href="../text/cluster/struct.Token.html#structfield.data"><code>data</code></a> field to the index of your span so
it can be recovered. Have you used the
<a href="../text/struct.Analyze.html"><code>Analyze</code></a> iterator to generate
<a href="../text/cluster/struct.CharInfo.html"><code>CharInfo</code></a>s containing boundary analysis? This
is where you apply them to the <a href="../text/cluster/struct.Token.html#structfield.info"><code>info</code></a> fields of your <a href="../text/cluster/struct.Token.html" title="Token"><code>Token</code></a>s.</p>
<p>That last one deserves a quick example, showing how you might build a cluster
parser with boundary analysis:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>swash::text::{analyze, Script};
<span class="kw">use </span>swash::text::cluster::{CharInfo, Parser, Token};
<span class="kw">let </span>text = <span class="string">&quot;a quick brown fox?&quot;</span>;
<span class="kw">let </span><span class="kw-2">mut </span>parser = Parser::new(
    Script::Latin,
    text.char_indices()
        <span class="comment">// Call analyze passing the same text and zip
        // the results
        </span>.zip(analyze(text.chars()))
        <span class="comment">// Analyze yields the tuple (Properties, Boundary)
        </span>.map(|((i, ch), (props, boundary))| Token {
            ch,
            offset: i <span class="kw">as </span>u32,
            len: ch.len_utf8() <span class="kw">as </span>u8,
            <span class="comment">// Create character information from properties and boundary
            </span>info: CharInfo::new(props, boundary),
            data: <span class="number">0</span>,
        }),
);</code></pre></div>
<p>That leaves us with font fallback. This crate does not provide the infrastructure
for such, but a small example can demonstrate the idea. The key is in
the return value of the <a href="../text/cluster/struct.CharCluster.html#method.map" title="CharCluster::map"><code>CharCluster::map</code></a> method which describes the
<a href="../text/cluster/enum.Status.html"><code>Status</code></a> of the mapping operation. This function
will return the index of the best matching font:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">use </span>swash::FontRef;
<span class="kw">use </span>swash::text::cluster::{CharCluster, Status};

<span class="kw">fn </span>select_font&lt;<span class="lifetime">&#39;a</span>&gt;(fonts: <span class="kw-2">&amp;</span>[FontRef&lt;<span class="lifetime">&#39;a</span>&gt;], cluster: <span class="kw-2">&amp;mut </span>CharCluster) -&gt; <span class="prelude-ty">Option</span>&lt;usize&gt; {
    <span class="kw">let </span><span class="kw-2">mut </span>best = <span class="prelude-val">None</span>;
    <span class="kw">for </span>(i, font) <span class="kw">in </span>fonts.iter().enumerate() {
        <span class="kw">let </span>charmap = font.charmap();
        <span class="kw">match </span>cluster.map(|ch| charmap.map(ch)) {
            <span class="comment">// This font provided a glyph for every character
            </span>Status::Complete =&gt; <span class="kw">return </span><span class="prelude-val">Some</span>(i),
            <span class="comment">// This font provided the most complete mapping so far
            </span>Status::Keep =&gt; best = <span class="prelude-val">Some</span>(i),
            <span class="comment">// A previous mapping was more complete
            </span>Status::Discard =&gt; {}
        }
    }
    best
}</code></pre></div>
<p>Note that <a href="../text/cluster/struct.CharCluster.html" title="CharCluster"><code>CharCluster</code></a> maintains internal composed and decomposed sequences
of the characters in the cluster so that it can select the best form for each
candidate font.</p>
<p>Since this process is done during shaping, upon return we compare the selected
font with our current font and if they’re different, we complete shaping for the
clusters submitted so far and continue the process by building a new shaper with
the selected font. By doing manual cluster parsing and nominal glyph mapping
<em>outside</em> the shaper, we can implement per-cluster font fallback without the costly
technique of heuristically shaping runs.</p>
<h2 id="collecting-the-prize"><a href="#collecting-the-prize">Collecting the prize</a></h2>
<p>Finish up shaping by calling <a href="struct.Shaper.html#method.shape_with" title="Shaper::shape_with"><code>Shaper::shape_with</code></a> with a closure that will be
invoked with each resulting <a href="cluster/struct.GlyphCluster.html" title="GlyphCluster"><code>GlyphCluster</code></a>. This structure contains borrowed data
and thus cannot be stored directly. The data you extract from each cluster and the
method in which you store it will depend entirely on the design of your text layout
system.</p>
<p>Please note that, unlike HarfBuzz, this shaper does <em>not</em> reverse runs that are in
right-to-left order. The reasoning is that, for correctness, line breaking must be
done in logical order and reversing runs should occur during bidi reordering.</p>
<p>Also pertinent to right-to-left runs: you’ll need to ensure that you reverse
<em>clusters</em> and not <em>glyphs</em>. Intra-cluster glyphs must remain in logical order
for proper mark placement.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="cluster/index.html" title="swash::shape::cluster mod">cluster</a></div><div class="item-right docblock-short">Glyph cluster modeling– output from the shaper.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ShapeContext.html" title="swash::shape::ShapeContext struct">ShapeContext</a></div><div class="item-right docblock-short">Context that manages caches and transient buffers for shaping.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Shaper.html" title="swash::shape::Shaper struct">Shaper</a></div><div class="item-right docblock-short">Maps character clusters to positioned glyph clusters according to
typographic rules and features.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ShaperBuilder.html" title="swash::shape::ShaperBuilder struct">ShaperBuilder</a></div><div class="item-right docblock-short">Builder for configuring a shaper.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Direction.html" title="swash::shape::Direction enum">Direction</a></div><div class="item-right docblock-short">Text direction.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="swash" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>