<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Scaling, hinting and rasterization of visual glyph representations."><meta name="keywords" content="rust, rustlang, rust-lang, scale"><title>swash::scale - Rust</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../normalize.css"><link rel="stylesheet" href="../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../ayu.css" disabled><link rel="stylesheet" href="../../dark.css" disabled><link rel="stylesheet" href="../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../storage.js"></script><script defer src="../../main.js"></script><noscript><link rel="stylesheet" href="../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../favicon.svg"></head><body class="rustdoc mod"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></div></a><h2 class="location"><a href="#">Module scale</a></h2><div class="sidebar-elems"><section><div class="block"><ul><li><a href="#modules">Modules</a></li><li><a href="#structs">Structs</a></li><li><a href="#enums">Enums</a></li><li><a href="#types">Type Definitions</a></li></ul></div></section></div></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../swash/index.html"><img class="rust-logo" src="../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="main-heading"><h1 class="fqn"><span class="in-band">Module <a href="../index.html">swash</a>::<wbr><a class="mod" href="#">scale</a><button id="copy-path" onclick="copy_path(this)" title="Copy item path to clipboard"><img src="../../clipboard.svg" width="19" height="18" alt="Copy item path"></button></span></h1><span class="out-of-band"><a class="srclink" href="../../src/swash/scale/mod.rs.html#1-1111">source</a> · <a id="toggle-all-docs" href="javascript:void(0)" title="collapse all docs">[<span class="inner">&#x2212;</span>]</a></span></div><details class="rustdoc-toggle top-doc" open><summary class="hideme"><span>Expand description</span></summary><div class="docblock"><p>Scaling, hinting and rasterization of visual glyph representations.</p>
<p>Scaling is the process of generating an appropriately sized visual
representation of a glyph. The scaler can produce rendered glyph
<a href="image/struct.Image.html">images</a> from outlines, layered color outlines and embedded
bitmaps. Alternatively, you can request raw, optionally hinted
<a href="outline/struct.Outline.html">outlines</a> that can then be further processed by <a href="../../zeno/index.html" title="zeno">zeno</a> or
fed into other crates like <a href="https://github.com/nical/lyon">lyon</a> or
<a href="https://github.com/servo/pathfinder">pathfinder</a> for tessellation and
GPU rendering.</p>
<h2 id="building-the-scaler"><a href="#building-the-scaler">Building the scaler</a></h2>
<p>All scaling in this crate takes place within the purview of a
<a href="struct.ScaleContext.html" title="ScaleContext"><code>ScaleContext</code></a>. This opaque struct manages internal LRU caches and scratch
buffers that are necessary for the scaling process. Generally, you’ll
want to keep an instance with your glyph cache, or if doing multithreaded
glyph rasterization, one instance per thread.</p>
<p>The only method available on the context is <a href="struct.ScaleContext.html#method.builder"><code>builder</code></a>
which takes a type that can be converted into a <a href="../struct.FontRef.html" title="FontRef"><code>FontRef</code></a> as an argument
and produces a <a href="struct.ScalerBuilder.html" title="ScalerBuilder"><code>ScalerBuilder</code></a> that provides options for configuring and
building a <a href="struct.Scaler.html" title="Scaler"><code>Scaler</code></a>.</p>
<p>Here, we’ll create a context and build a scaler for a size of 14px with
hinting enabled:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font)
    .size(<span class="number">14.</span>)
    .hint(<span class="bool-val">true</span>)
    .build();</code></pre></div>
<p>You can specify variation settings by calling the <a href="struct.ScalerBuilder.html#method.variations"><code>variations</code></a>
method with an iterator that yields a sequence of values that are convertible
to <a href="../struct.Setting.html" title="Setting&lt;f32&gt;"><code>Setting&lt;f32&gt;</code></a>. Tuples of (&amp;str, f32) will work in a pinch. For example,
you can request a variation of the weight axis like this:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font)
    .size(<span class="number">14.</span>)
    .hint(<span class="bool-val">true</span>)
    .variations(<span class="kw-2">&amp;</span>[(<span class="string">&quot;wght&quot;</span>, <span class="number">520.5</span>)])
    .build();</code></pre></div>
<p>Alternatively, you can specify variations using the
<a href="struct.ScalerBuilder.html#method.normalized_coords"><code>normalized_coords</code></a> method which takes an iterator
that yields <a href="../type.NormalizedCoord.html" title="NormalizedCoord"><code>NormalizedCoord</code></a>s (a type alias for <code>i16</code> which is a fixed point value
in 2.14 format). This method is faster than specifying variations by tag and value, but
the difference is likely negligible outside of microbenchmarks. The real advantage
is that a sequence of <code>i16</code> is more compact and easier to fold into a key in a glyph
cache. You can compute these normalized coordinates by using the
<a href="../struct.Variation.html#method.normalize"><code>Variation::normalize</code></a> method for each available axis in
the font. The best strategy, however, is to simply capture these during shaping with
the <a href="../shape/struct.Shaper.html#method.normalized_coords"><code>Shaper::normalized_coords</code></a> method which
will have already computed them for you.</p>
<p>See <a href="struct.ScalerBuilder.html" title="ScalerBuilder"><code>ScalerBuilder</code></a> for available options and default values.</p>
<h2 id="outlines-and-bitmaps"><a href="#outlines-and-bitmaps">Outlines and bitmaps</a></h2>
<p>The <a href="struct.Scaler.html" title="Scaler"><code>Scaler</code></a> struct essentially provides direct access to the outlines and embedded
bitmaps that are available in the font. In the case of outlines, it can produce the
raw outline in font units or an optionally hinted, scaled outline. For example, to
extract the raw outline for the letter ‘Q’:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font).build();
<span class="kw">let </span>glyph_id = font.charmap().map(<span class="string">&#39;Q&#39;</span>);
<span class="kw">let </span>outline = scaler.scale_outline(glyph_id);</code></pre></div>
<p>For the same, but hinted at 12px:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font)
    .hint(<span class="bool-val">true</span>)
    .size(<span class="number">12.</span>)
    .build();
<span class="kw">let </span>glyph_id = font.charmap().map(<span class="string">&#39;Q&#39;</span>);
<span class="kw">let </span>outline = scaler.scale_outline(glyph_id);</code></pre></div>
<p>The <a href="struct.Scaler.html#method.scale_outline"><code>scale_outline</code></a> method returns an <a href="outline/struct.Outline.html" title="Outline"><code>Outline</code></a> wrapped
in an option. It will return <code>None</code> if an outline was not available or if there was
an error during the scaling process. Note that
<a href="struct.Scaler.html#method.scale_color_outline"><code>scale_color_outline</code></a> can be used to access layered
color outlines such as those included in the Microsoft <em>Segoe UI Emoji</em> font. Finally,
the <code>_into</code> variants of these methods (<a href="struct.Scaler.html#method.scale_outline_into"><code>scale_outline_into</code></a>
and <a href="struct.Scaler.html#method.scale_color_outline_into"><code>scale_color_outline_into</code></a>) will return
their results in a previously allocated outline avoiding the extra allocations.</p>
<p>Similar to outlines, bitmaps can be retrieved with the <a href="struct.Scaler.html#method.scale_bitmap"><code>scale_bitmap</code></a>
and <a href="struct.Scaler.html#method.scale_color_bitmap"><code>scale_color_bitmap</code></a> for alpha and color bitmaps,
respectively. These methods return an <a href="image/struct.Image.html" title="Image"><code>Image</code></a> wrapped in an option. The associated
<code>_into</code> variants are also available.</p>
<p>Unlike outlines, bitmaps are available in <a href="../struct.BitmapStrike.html"><code>strike</code></a>s of various sizes.
When requesting a bitmap, you specify the strategy for strike selection using the
<a href="enum.StrikeWith.html" title="StrikeWith"><code>StrikeWith</code></a> enum.</p>
<p>For example, if we want the largest available unscaled image for the fire emoji:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font).build();
<span class="kw">let </span>glyph_id = font.charmap().map(<span class="string">&#39;🔥&#39;</span>);
<span class="kw">let </span>image = scaler.scale_color_bitmap(glyph_id, StrikeWith::LargestSize);</code></pre></div>
<p>Or, to produce a scaled image for a size of 18px:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="comment">// let font = ...;
</span><span class="kw">let </span><span class="kw-2">mut </span>context = ScaleContext::new();
<span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(font)
    .size(<span class="number">18.</span>)
    .build();
<span class="kw">let </span>glyph_id = font.charmap().map(<span class="string">&#39;🔥&#39;</span>);
<span class="kw">let </span>image = scaler.scale_color_bitmap(glyph_id, StrikeWith::BestFit);</code></pre></div>
<p>This will select the best strike for the requested size and return
a bitmap that is scaled appropriately for an 18px run of text.</p>
<p>Alpha bitmaps should generally be avoided unless you’re rendering small East
Asian text where these are sometimes still preferred over scalable outlines. In
this case, you should only use <a href="enum.StrikeWith.html#variant.ExactSize" title="StrikeWith::ExactSize"><code>StrikeWith::ExactSize</code></a> to select the strike,
falling back to an outline if a bitmap is unavailable.</p>
<h2 id="rendering"><a href="#rendering">Rendering</a></h2>
<p>In the general case of text rendering, you’ll likely not care about the specific
details of outlines or bitmaps and will simply want an appropriately sized
image that represents your glyph. For this purpose, you’ll want to use the
<a href="struct.Render.html" title="Render"><code>Render</code></a> struct which is a builder that provides options for rendering an image.
This struct is constructed with a slice of <a href="enum.Source.html" title="Source"><code>Source</code></a>s in priority order and
will iterate through them until it finds one that satisfies the request. Typically,
you’ll want to use the following order:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code>Render::new(<span class="kw-2">&amp;</span>[
    <span class="comment">// Color outline with the first palette
    </span>Source::ColorOutline(<span class="number">0</span>),
    <span class="comment">// Color bitmap with best fit selection mode
    </span>Source::ColorBitmap(StrikeWith::BestFit),
    <span class="comment">// Standard scalable outline
    </span>Source::Outline,
]);</code></pre></div>
<p>The <a href="struct.Render.html" title="Render"><code>Render</code></a> struct offers several options that control rasterization of
outlines such as <a href="struct.Render.html#method.format"><code>format</code></a> for selecting a subpixel rendering mode,
<a href="struct.Render.html#method.offset"><code>offset</code></a> for applying fractional positioning, and others. See the
struct documentation for detail.</p>
<p>After selecting your options, call the <a href="struct.Render.html#method.render"><code>render</code></a> method, passing your
configured <a href="struct.Scaler.html" title="Scaler"><code>Scaler</code></a> and the requested glyph identifier to produce an <a href="image/struct.Image.html" title="Image"><code>Image</code></a>.
Let’s put it all together by writing a simple function that will render subpixel glyphs
with fractional positioning:</p>

<div class="example-wrap"><pre class="rust rust-example-rendered"><code><span class="kw">fn </span>render_glyph(
    context: <span class="kw-2">&amp;mut </span>ScaleContext,
    font: <span class="kw-2">&amp;</span>FontRef,
    size: f32,
    hint: bool,
    glyph_id: GlyphId,
    x: f32,
    y: f32,
) -&gt; <span class="prelude-ty">Option</span>&lt;Image&gt; {
    <span class="kw">use </span>zeno::{Format, Vector};
    <span class="comment">// Build the scaler
    </span><span class="kw">let </span><span class="kw-2">mut </span>scaler = context.builder(<span class="kw-2">*</span>font).size(size).hint(hint).build();
    <span class="comment">// Compute the fractional offset-- you&#39;ll likely want to quantize this
    // in a real renderer
    </span><span class="kw">let </span>offset = Vector::new(x.fract(), y.fract());
    <span class="comment">// Select our source order
    </span>Render::new(<span class="kw-2">&amp;</span>[
        Source::ColorOutline(<span class="number">0</span>),
        Source::ColorBitmap(StrikeWith::BestFit),
        Source::Outline,
    ])
    <span class="comment">// Select a subpixel format
    </span>.format(Format::Subpixel)
    <span class="comment">// Apply the fractional offset
    </span>.offset(offset)
    <span class="comment">// Render the image
    </span>.render(<span class="kw-2">&amp;mut </span>scaler, glyph_id)
}</code></pre></div>
<p>Note that rendering also takes care of correctly scaling, rasterizing and
compositing layered color outlines for us.</p>
<p>There are other options available for emboldening, transforming with an
affine matrix, and applying path effects. See the methods on <a href="struct.Render.html" title="Render"><code>Render</code></a> for
more detail.</p>
</div></details><h2 id="modules" class="small-section-header"><a href="#modules">Modules</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="mod" href="image/index.html" title="swash::scale::image mod">image</a></div><div class="item-right docblock-short">Rendered glyph image.</div></div><div class="item-row"><div class="item-left module-item"><a class="mod" href="outline/index.html" title="swash::scale::outline mod">outline</a></div><div class="item-right docblock-short">Glyph outline.</div></div></div><h2 id="structs" class="small-section-header"><a href="#structs">Structs</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Render.html" title="swash::scale::Render struct">Render</a></div><div class="item-right docblock-short">Builder type for rendering a glyph into an image.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ScaleContext.html" title="swash::scale::ScaleContext struct">ScaleContext</a></div><div class="item-right docblock-short">Context that manages caches and scratch buffers for scaling.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.Scaler.html" title="swash::scale::Scaler struct">Scaler</a></div><div class="item-right docblock-short">Scales outline and bitmap glyphs.</div></div><div class="item-row"><div class="item-left module-item"><a class="struct" href="struct.ScalerBuilder.html" title="swash::scale::ScalerBuilder struct">ScalerBuilder</a></div><div class="item-right docblock-short">Builder for configuring a scaler.</div></div></div><h2 id="enums" class="small-section-header"><a href="#enums">Enums</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.Source.html" title="swash::scale::Source enum">Source</a></div><div class="item-right docblock-short">Glyph sources for the renderer.</div></div><div class="item-row"><div class="item-left module-item"><a class="enum" href="enum.StrikeWith.html" title="swash::scale::StrikeWith enum">StrikeWith</a></div><div class="item-right docblock-short">Bitmap strike selection mode.</div></div></div><h2 id="types" class="small-section-header"><a href="#types">Type Definitions</a></h2><div class="item-table"><div class="item-row"><div class="item-left module-item"><a class="type" href="type.PaletteIndex.html" title="swash::scale::PaletteIndex type">PaletteIndex</a></div><div class="item-right docblock-short">Index of a color palette.</div></div><div class="item-row"><div class="item-left module-item"><a class="type" href="type.StrikeIndex.html" title="swash::scale::StrikeIndex type">StrikeIndex</a></div><div class="item-right docblock-short">Index of a bitmap strike.</div></div></div></section></div></main><div id="rustdoc-vars" data-root-path="../../" data-current-crate="swash" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>