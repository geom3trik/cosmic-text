<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta name="viewport" content="width=device-width, initial-scale=1.0"><meta name="generator" content="rustdoc"><meta name="description" content="Source of the Rust file `/home/runner/.cargo/registry/src/github.com-1ecc6299db9ec823/swash-0.1.5/src/scale/mod.rs`."><meta name="keywords" content="rust, rustlang, rust-lang"><title>mod.rs - source</title><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Regular.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../FiraSans-Medium.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Regular.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceSerif4-Bold.ttf.woff2"><link rel="preload" as="font" type="font/woff2" crossorigin href="../../../SourceCodePro-Semibold.ttf.woff2"><link rel="stylesheet" href="../../../normalize.css"><link rel="stylesheet" href="../../../rustdoc.css" id="mainThemeStyle"><link rel="stylesheet" href="../../../ayu.css" disabled><link rel="stylesheet" href="../../../dark.css" disabled><link rel="stylesheet" href="../../../light.css" id="themeStyle"><script id="default-settings" ></script><script src="../../../storage.js"></script><script defer src="../../../source-script.js"></script><script defer src="../../../source-files.js"></script><script defer src="../../../main.js"></script><noscript><link rel="stylesheet" href="../../../noscript.css"></noscript><link rel="alternate icon" type="image/png" href="../../../favicon-16x16.png"><link rel="alternate icon" type="image/png" href="../../../favicon-32x32.png"><link rel="icon" type="image/svg+xml" href="../../../favicon.svg"></head><body class="rustdoc source"><!--[if lte IE 11]><div class="warning">This old browser is unsupported and will most likely display funky things.</div><![endif]--><nav class="mobile-topbar"><button class="sidebar-menu-toggle">&#9776;</button><a class="sidebar-logo" href="../../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a><h2 class="location"></h2></nav><nav class="sidebar"><a class="sidebar-logo" href="../../../swash/index.html"><div class="logo-container"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></div></a></nav><main><div class="width-limiter"><div class="sub-container"><a class="sub-logo-container" href="../../../swash/index.html"><img class="rust-logo" src="../../../rust-logo.svg" alt="logo"></a><nav class="sub"><form class="search-form"><div class="search-container"><span></span><input class="search-input" name="search" autocomplete="off" spellcheck="false" placeholder="Click or press ‘S’ to search, ‘?’ for more options…" type="search"><div id="help-button" title="help" tabindex="-1"><button type="button">?</button></div><div id="settings-menu" tabindex="-1"><a href="../../../settings.html" title="settings"><img width="22" height="22" alt="Change settings" src="../../../wheel.svg"></a></div></div></form></nav></div><section id="main-content" class="content"><div class="example-wrap"><pre class="line-numbers"><span id="1">1</span>
<span id="2">2</span>
<span id="3">3</span>
<span id="4">4</span>
<span id="5">5</span>
<span id="6">6</span>
<span id="7">7</span>
<span id="8">8</span>
<span id="9">9</span>
<span id="10">10</span>
<span id="11">11</span>
<span id="12">12</span>
<span id="13">13</span>
<span id="14">14</span>
<span id="15">15</span>
<span id="16">16</span>
<span id="17">17</span>
<span id="18">18</span>
<span id="19">19</span>
<span id="20">20</span>
<span id="21">21</span>
<span id="22">22</span>
<span id="23">23</span>
<span id="24">24</span>
<span id="25">25</span>
<span id="26">26</span>
<span id="27">27</span>
<span id="28">28</span>
<span id="29">29</span>
<span id="30">30</span>
<span id="31">31</span>
<span id="32">32</span>
<span id="33">33</span>
<span id="34">34</span>
<span id="35">35</span>
<span id="36">36</span>
<span id="37">37</span>
<span id="38">38</span>
<span id="39">39</span>
<span id="40">40</span>
<span id="41">41</span>
<span id="42">42</span>
<span id="43">43</span>
<span id="44">44</span>
<span id="45">45</span>
<span id="46">46</span>
<span id="47">47</span>
<span id="48">48</span>
<span id="49">49</span>
<span id="50">50</span>
<span id="51">51</span>
<span id="52">52</span>
<span id="53">53</span>
<span id="54">54</span>
<span id="55">55</span>
<span id="56">56</span>
<span id="57">57</span>
<span id="58">58</span>
<span id="59">59</span>
<span id="60">60</span>
<span id="61">61</span>
<span id="62">62</span>
<span id="63">63</span>
<span id="64">64</span>
<span id="65">65</span>
<span id="66">66</span>
<span id="67">67</span>
<span id="68">68</span>
<span id="69">69</span>
<span id="70">70</span>
<span id="71">71</span>
<span id="72">72</span>
<span id="73">73</span>
<span id="74">74</span>
<span id="75">75</span>
<span id="76">76</span>
<span id="77">77</span>
<span id="78">78</span>
<span id="79">79</span>
<span id="80">80</span>
<span id="81">81</span>
<span id="82">82</span>
<span id="83">83</span>
<span id="84">84</span>
<span id="85">85</span>
<span id="86">86</span>
<span id="87">87</span>
<span id="88">88</span>
<span id="89">89</span>
<span id="90">90</span>
<span id="91">91</span>
<span id="92">92</span>
<span id="93">93</span>
<span id="94">94</span>
<span id="95">95</span>
<span id="96">96</span>
<span id="97">97</span>
<span id="98">98</span>
<span id="99">99</span>
<span id="100">100</span>
<span id="101">101</span>
<span id="102">102</span>
<span id="103">103</span>
<span id="104">104</span>
<span id="105">105</span>
<span id="106">106</span>
<span id="107">107</span>
<span id="108">108</span>
<span id="109">109</span>
<span id="110">110</span>
<span id="111">111</span>
<span id="112">112</span>
<span id="113">113</span>
<span id="114">114</span>
<span id="115">115</span>
<span id="116">116</span>
<span id="117">117</span>
<span id="118">118</span>
<span id="119">119</span>
<span id="120">120</span>
<span id="121">121</span>
<span id="122">122</span>
<span id="123">123</span>
<span id="124">124</span>
<span id="125">125</span>
<span id="126">126</span>
<span id="127">127</span>
<span id="128">128</span>
<span id="129">129</span>
<span id="130">130</span>
<span id="131">131</span>
<span id="132">132</span>
<span id="133">133</span>
<span id="134">134</span>
<span id="135">135</span>
<span id="136">136</span>
<span id="137">137</span>
<span id="138">138</span>
<span id="139">139</span>
<span id="140">140</span>
<span id="141">141</span>
<span id="142">142</span>
<span id="143">143</span>
<span id="144">144</span>
<span id="145">145</span>
<span id="146">146</span>
<span id="147">147</span>
<span id="148">148</span>
<span id="149">149</span>
<span id="150">150</span>
<span id="151">151</span>
<span id="152">152</span>
<span id="153">153</span>
<span id="154">154</span>
<span id="155">155</span>
<span id="156">156</span>
<span id="157">157</span>
<span id="158">158</span>
<span id="159">159</span>
<span id="160">160</span>
<span id="161">161</span>
<span id="162">162</span>
<span id="163">163</span>
<span id="164">164</span>
<span id="165">165</span>
<span id="166">166</span>
<span id="167">167</span>
<span id="168">168</span>
<span id="169">169</span>
<span id="170">170</span>
<span id="171">171</span>
<span id="172">172</span>
<span id="173">173</span>
<span id="174">174</span>
<span id="175">175</span>
<span id="176">176</span>
<span id="177">177</span>
<span id="178">178</span>
<span id="179">179</span>
<span id="180">180</span>
<span id="181">181</span>
<span id="182">182</span>
<span id="183">183</span>
<span id="184">184</span>
<span id="185">185</span>
<span id="186">186</span>
<span id="187">187</span>
<span id="188">188</span>
<span id="189">189</span>
<span id="190">190</span>
<span id="191">191</span>
<span id="192">192</span>
<span id="193">193</span>
<span id="194">194</span>
<span id="195">195</span>
<span id="196">196</span>
<span id="197">197</span>
<span id="198">198</span>
<span id="199">199</span>
<span id="200">200</span>
<span id="201">201</span>
<span id="202">202</span>
<span id="203">203</span>
<span id="204">204</span>
<span id="205">205</span>
<span id="206">206</span>
<span id="207">207</span>
<span id="208">208</span>
<span id="209">209</span>
<span id="210">210</span>
<span id="211">211</span>
<span id="212">212</span>
<span id="213">213</span>
<span id="214">214</span>
<span id="215">215</span>
<span id="216">216</span>
<span id="217">217</span>
<span id="218">218</span>
<span id="219">219</span>
<span id="220">220</span>
<span id="221">221</span>
<span id="222">222</span>
<span id="223">223</span>
<span id="224">224</span>
<span id="225">225</span>
<span id="226">226</span>
<span id="227">227</span>
<span id="228">228</span>
<span id="229">229</span>
<span id="230">230</span>
<span id="231">231</span>
<span id="232">232</span>
<span id="233">233</span>
<span id="234">234</span>
<span id="235">235</span>
<span id="236">236</span>
<span id="237">237</span>
<span id="238">238</span>
<span id="239">239</span>
<span id="240">240</span>
<span id="241">241</span>
<span id="242">242</span>
<span id="243">243</span>
<span id="244">244</span>
<span id="245">245</span>
<span id="246">246</span>
<span id="247">247</span>
<span id="248">248</span>
<span id="249">249</span>
<span id="250">250</span>
<span id="251">251</span>
<span id="252">252</span>
<span id="253">253</span>
<span id="254">254</span>
<span id="255">255</span>
<span id="256">256</span>
<span id="257">257</span>
<span id="258">258</span>
<span id="259">259</span>
<span id="260">260</span>
<span id="261">261</span>
<span id="262">262</span>
<span id="263">263</span>
<span id="264">264</span>
<span id="265">265</span>
<span id="266">266</span>
<span id="267">267</span>
<span id="268">268</span>
<span id="269">269</span>
<span id="270">270</span>
<span id="271">271</span>
<span id="272">272</span>
<span id="273">273</span>
<span id="274">274</span>
<span id="275">275</span>
<span id="276">276</span>
<span id="277">277</span>
<span id="278">278</span>
<span id="279">279</span>
<span id="280">280</span>
<span id="281">281</span>
<span id="282">282</span>
<span id="283">283</span>
<span id="284">284</span>
<span id="285">285</span>
<span id="286">286</span>
<span id="287">287</span>
<span id="288">288</span>
<span id="289">289</span>
<span id="290">290</span>
<span id="291">291</span>
<span id="292">292</span>
<span id="293">293</span>
<span id="294">294</span>
<span id="295">295</span>
<span id="296">296</span>
<span id="297">297</span>
<span id="298">298</span>
<span id="299">299</span>
<span id="300">300</span>
<span id="301">301</span>
<span id="302">302</span>
<span id="303">303</span>
<span id="304">304</span>
<span id="305">305</span>
<span id="306">306</span>
<span id="307">307</span>
<span id="308">308</span>
<span id="309">309</span>
<span id="310">310</span>
<span id="311">311</span>
<span id="312">312</span>
<span id="313">313</span>
<span id="314">314</span>
<span id="315">315</span>
<span id="316">316</span>
<span id="317">317</span>
<span id="318">318</span>
<span id="319">319</span>
<span id="320">320</span>
<span id="321">321</span>
<span id="322">322</span>
<span id="323">323</span>
<span id="324">324</span>
<span id="325">325</span>
<span id="326">326</span>
<span id="327">327</span>
<span id="328">328</span>
<span id="329">329</span>
<span id="330">330</span>
<span id="331">331</span>
<span id="332">332</span>
<span id="333">333</span>
<span id="334">334</span>
<span id="335">335</span>
<span id="336">336</span>
<span id="337">337</span>
<span id="338">338</span>
<span id="339">339</span>
<span id="340">340</span>
<span id="341">341</span>
<span id="342">342</span>
<span id="343">343</span>
<span id="344">344</span>
<span id="345">345</span>
<span id="346">346</span>
<span id="347">347</span>
<span id="348">348</span>
<span id="349">349</span>
<span id="350">350</span>
<span id="351">351</span>
<span id="352">352</span>
<span id="353">353</span>
<span id="354">354</span>
<span id="355">355</span>
<span id="356">356</span>
<span id="357">357</span>
<span id="358">358</span>
<span id="359">359</span>
<span id="360">360</span>
<span id="361">361</span>
<span id="362">362</span>
<span id="363">363</span>
<span id="364">364</span>
<span id="365">365</span>
<span id="366">366</span>
<span id="367">367</span>
<span id="368">368</span>
<span id="369">369</span>
<span id="370">370</span>
<span id="371">371</span>
<span id="372">372</span>
<span id="373">373</span>
<span id="374">374</span>
<span id="375">375</span>
<span id="376">376</span>
<span id="377">377</span>
<span id="378">378</span>
<span id="379">379</span>
<span id="380">380</span>
<span id="381">381</span>
<span id="382">382</span>
<span id="383">383</span>
<span id="384">384</span>
<span id="385">385</span>
<span id="386">386</span>
<span id="387">387</span>
<span id="388">388</span>
<span id="389">389</span>
<span id="390">390</span>
<span id="391">391</span>
<span id="392">392</span>
<span id="393">393</span>
<span id="394">394</span>
<span id="395">395</span>
<span id="396">396</span>
<span id="397">397</span>
<span id="398">398</span>
<span id="399">399</span>
<span id="400">400</span>
<span id="401">401</span>
<span id="402">402</span>
<span id="403">403</span>
<span id="404">404</span>
<span id="405">405</span>
<span id="406">406</span>
<span id="407">407</span>
<span id="408">408</span>
<span id="409">409</span>
<span id="410">410</span>
<span id="411">411</span>
<span id="412">412</span>
<span id="413">413</span>
<span id="414">414</span>
<span id="415">415</span>
<span id="416">416</span>
<span id="417">417</span>
<span id="418">418</span>
<span id="419">419</span>
<span id="420">420</span>
<span id="421">421</span>
<span id="422">422</span>
<span id="423">423</span>
<span id="424">424</span>
<span id="425">425</span>
<span id="426">426</span>
<span id="427">427</span>
<span id="428">428</span>
<span id="429">429</span>
<span id="430">430</span>
<span id="431">431</span>
<span id="432">432</span>
<span id="433">433</span>
<span id="434">434</span>
<span id="435">435</span>
<span id="436">436</span>
<span id="437">437</span>
<span id="438">438</span>
<span id="439">439</span>
<span id="440">440</span>
<span id="441">441</span>
<span id="442">442</span>
<span id="443">443</span>
<span id="444">444</span>
<span id="445">445</span>
<span id="446">446</span>
<span id="447">447</span>
<span id="448">448</span>
<span id="449">449</span>
<span id="450">450</span>
<span id="451">451</span>
<span id="452">452</span>
<span id="453">453</span>
<span id="454">454</span>
<span id="455">455</span>
<span id="456">456</span>
<span id="457">457</span>
<span id="458">458</span>
<span id="459">459</span>
<span id="460">460</span>
<span id="461">461</span>
<span id="462">462</span>
<span id="463">463</span>
<span id="464">464</span>
<span id="465">465</span>
<span id="466">466</span>
<span id="467">467</span>
<span id="468">468</span>
<span id="469">469</span>
<span id="470">470</span>
<span id="471">471</span>
<span id="472">472</span>
<span id="473">473</span>
<span id="474">474</span>
<span id="475">475</span>
<span id="476">476</span>
<span id="477">477</span>
<span id="478">478</span>
<span id="479">479</span>
<span id="480">480</span>
<span id="481">481</span>
<span id="482">482</span>
<span id="483">483</span>
<span id="484">484</span>
<span id="485">485</span>
<span id="486">486</span>
<span id="487">487</span>
<span id="488">488</span>
<span id="489">489</span>
<span id="490">490</span>
<span id="491">491</span>
<span id="492">492</span>
<span id="493">493</span>
<span id="494">494</span>
<span id="495">495</span>
<span id="496">496</span>
<span id="497">497</span>
<span id="498">498</span>
<span id="499">499</span>
<span id="500">500</span>
<span id="501">501</span>
<span id="502">502</span>
<span id="503">503</span>
<span id="504">504</span>
<span id="505">505</span>
<span id="506">506</span>
<span id="507">507</span>
<span id="508">508</span>
<span id="509">509</span>
<span id="510">510</span>
<span id="511">511</span>
<span id="512">512</span>
<span id="513">513</span>
<span id="514">514</span>
<span id="515">515</span>
<span id="516">516</span>
<span id="517">517</span>
<span id="518">518</span>
<span id="519">519</span>
<span id="520">520</span>
<span id="521">521</span>
<span id="522">522</span>
<span id="523">523</span>
<span id="524">524</span>
<span id="525">525</span>
<span id="526">526</span>
<span id="527">527</span>
<span id="528">528</span>
<span id="529">529</span>
<span id="530">530</span>
<span id="531">531</span>
<span id="532">532</span>
<span id="533">533</span>
<span id="534">534</span>
<span id="535">535</span>
<span id="536">536</span>
<span id="537">537</span>
<span id="538">538</span>
<span id="539">539</span>
<span id="540">540</span>
<span id="541">541</span>
<span id="542">542</span>
<span id="543">543</span>
<span id="544">544</span>
<span id="545">545</span>
<span id="546">546</span>
<span id="547">547</span>
<span id="548">548</span>
<span id="549">549</span>
<span id="550">550</span>
<span id="551">551</span>
<span id="552">552</span>
<span id="553">553</span>
<span id="554">554</span>
<span id="555">555</span>
<span id="556">556</span>
<span id="557">557</span>
<span id="558">558</span>
<span id="559">559</span>
<span id="560">560</span>
<span id="561">561</span>
<span id="562">562</span>
<span id="563">563</span>
<span id="564">564</span>
<span id="565">565</span>
<span id="566">566</span>
<span id="567">567</span>
<span id="568">568</span>
<span id="569">569</span>
<span id="570">570</span>
<span id="571">571</span>
<span id="572">572</span>
<span id="573">573</span>
<span id="574">574</span>
<span id="575">575</span>
<span id="576">576</span>
<span id="577">577</span>
<span id="578">578</span>
<span id="579">579</span>
<span id="580">580</span>
<span id="581">581</span>
<span id="582">582</span>
<span id="583">583</span>
<span id="584">584</span>
<span id="585">585</span>
<span id="586">586</span>
<span id="587">587</span>
<span id="588">588</span>
<span id="589">589</span>
<span id="590">590</span>
<span id="591">591</span>
<span id="592">592</span>
<span id="593">593</span>
<span id="594">594</span>
<span id="595">595</span>
<span id="596">596</span>
<span id="597">597</span>
<span id="598">598</span>
<span id="599">599</span>
<span id="600">600</span>
<span id="601">601</span>
<span id="602">602</span>
<span id="603">603</span>
<span id="604">604</span>
<span id="605">605</span>
<span id="606">606</span>
<span id="607">607</span>
<span id="608">608</span>
<span id="609">609</span>
<span id="610">610</span>
<span id="611">611</span>
<span id="612">612</span>
<span id="613">613</span>
<span id="614">614</span>
<span id="615">615</span>
<span id="616">616</span>
<span id="617">617</span>
<span id="618">618</span>
<span id="619">619</span>
<span id="620">620</span>
<span id="621">621</span>
<span id="622">622</span>
<span id="623">623</span>
<span id="624">624</span>
<span id="625">625</span>
<span id="626">626</span>
<span id="627">627</span>
<span id="628">628</span>
<span id="629">629</span>
<span id="630">630</span>
<span id="631">631</span>
<span id="632">632</span>
<span id="633">633</span>
<span id="634">634</span>
<span id="635">635</span>
<span id="636">636</span>
<span id="637">637</span>
<span id="638">638</span>
<span id="639">639</span>
<span id="640">640</span>
<span id="641">641</span>
<span id="642">642</span>
<span id="643">643</span>
<span id="644">644</span>
<span id="645">645</span>
<span id="646">646</span>
<span id="647">647</span>
<span id="648">648</span>
<span id="649">649</span>
<span id="650">650</span>
<span id="651">651</span>
<span id="652">652</span>
<span id="653">653</span>
<span id="654">654</span>
<span id="655">655</span>
<span id="656">656</span>
<span id="657">657</span>
<span id="658">658</span>
<span id="659">659</span>
<span id="660">660</span>
<span id="661">661</span>
<span id="662">662</span>
<span id="663">663</span>
<span id="664">664</span>
<span id="665">665</span>
<span id="666">666</span>
<span id="667">667</span>
<span id="668">668</span>
<span id="669">669</span>
<span id="670">670</span>
<span id="671">671</span>
<span id="672">672</span>
<span id="673">673</span>
<span id="674">674</span>
<span id="675">675</span>
<span id="676">676</span>
<span id="677">677</span>
<span id="678">678</span>
<span id="679">679</span>
<span id="680">680</span>
<span id="681">681</span>
<span id="682">682</span>
<span id="683">683</span>
<span id="684">684</span>
<span id="685">685</span>
<span id="686">686</span>
<span id="687">687</span>
<span id="688">688</span>
<span id="689">689</span>
<span id="690">690</span>
<span id="691">691</span>
<span id="692">692</span>
<span id="693">693</span>
<span id="694">694</span>
<span id="695">695</span>
<span id="696">696</span>
<span id="697">697</span>
<span id="698">698</span>
<span id="699">699</span>
<span id="700">700</span>
<span id="701">701</span>
<span id="702">702</span>
<span id="703">703</span>
<span id="704">704</span>
<span id="705">705</span>
<span id="706">706</span>
<span id="707">707</span>
<span id="708">708</span>
<span id="709">709</span>
<span id="710">710</span>
<span id="711">711</span>
<span id="712">712</span>
<span id="713">713</span>
<span id="714">714</span>
<span id="715">715</span>
<span id="716">716</span>
<span id="717">717</span>
<span id="718">718</span>
<span id="719">719</span>
<span id="720">720</span>
<span id="721">721</span>
<span id="722">722</span>
<span id="723">723</span>
<span id="724">724</span>
<span id="725">725</span>
<span id="726">726</span>
<span id="727">727</span>
<span id="728">728</span>
<span id="729">729</span>
<span id="730">730</span>
<span id="731">731</span>
<span id="732">732</span>
<span id="733">733</span>
<span id="734">734</span>
<span id="735">735</span>
<span id="736">736</span>
<span id="737">737</span>
<span id="738">738</span>
<span id="739">739</span>
<span id="740">740</span>
<span id="741">741</span>
<span id="742">742</span>
<span id="743">743</span>
<span id="744">744</span>
<span id="745">745</span>
<span id="746">746</span>
<span id="747">747</span>
<span id="748">748</span>
<span id="749">749</span>
<span id="750">750</span>
<span id="751">751</span>
<span id="752">752</span>
<span id="753">753</span>
<span id="754">754</span>
<span id="755">755</span>
<span id="756">756</span>
<span id="757">757</span>
<span id="758">758</span>
<span id="759">759</span>
<span id="760">760</span>
<span id="761">761</span>
<span id="762">762</span>
<span id="763">763</span>
<span id="764">764</span>
<span id="765">765</span>
<span id="766">766</span>
<span id="767">767</span>
<span id="768">768</span>
<span id="769">769</span>
<span id="770">770</span>
<span id="771">771</span>
<span id="772">772</span>
<span id="773">773</span>
<span id="774">774</span>
<span id="775">775</span>
<span id="776">776</span>
<span id="777">777</span>
<span id="778">778</span>
<span id="779">779</span>
<span id="780">780</span>
<span id="781">781</span>
<span id="782">782</span>
<span id="783">783</span>
<span id="784">784</span>
<span id="785">785</span>
<span id="786">786</span>
<span id="787">787</span>
<span id="788">788</span>
<span id="789">789</span>
<span id="790">790</span>
<span id="791">791</span>
<span id="792">792</span>
<span id="793">793</span>
<span id="794">794</span>
<span id="795">795</span>
<span id="796">796</span>
<span id="797">797</span>
<span id="798">798</span>
<span id="799">799</span>
<span id="800">800</span>
<span id="801">801</span>
<span id="802">802</span>
<span id="803">803</span>
<span id="804">804</span>
<span id="805">805</span>
<span id="806">806</span>
<span id="807">807</span>
<span id="808">808</span>
<span id="809">809</span>
<span id="810">810</span>
<span id="811">811</span>
<span id="812">812</span>
<span id="813">813</span>
<span id="814">814</span>
<span id="815">815</span>
<span id="816">816</span>
<span id="817">817</span>
<span id="818">818</span>
<span id="819">819</span>
<span id="820">820</span>
<span id="821">821</span>
<span id="822">822</span>
<span id="823">823</span>
<span id="824">824</span>
<span id="825">825</span>
<span id="826">826</span>
<span id="827">827</span>
<span id="828">828</span>
<span id="829">829</span>
<span id="830">830</span>
<span id="831">831</span>
<span id="832">832</span>
<span id="833">833</span>
<span id="834">834</span>
<span id="835">835</span>
<span id="836">836</span>
<span id="837">837</span>
<span id="838">838</span>
<span id="839">839</span>
<span id="840">840</span>
<span id="841">841</span>
<span id="842">842</span>
<span id="843">843</span>
<span id="844">844</span>
<span id="845">845</span>
<span id="846">846</span>
<span id="847">847</span>
<span id="848">848</span>
<span id="849">849</span>
<span id="850">850</span>
<span id="851">851</span>
<span id="852">852</span>
<span id="853">853</span>
<span id="854">854</span>
<span id="855">855</span>
<span id="856">856</span>
<span id="857">857</span>
<span id="858">858</span>
<span id="859">859</span>
<span id="860">860</span>
<span id="861">861</span>
<span id="862">862</span>
<span id="863">863</span>
<span id="864">864</span>
<span id="865">865</span>
<span id="866">866</span>
<span id="867">867</span>
<span id="868">868</span>
<span id="869">869</span>
<span id="870">870</span>
<span id="871">871</span>
<span id="872">872</span>
<span id="873">873</span>
<span id="874">874</span>
<span id="875">875</span>
<span id="876">876</span>
<span id="877">877</span>
<span id="878">878</span>
<span id="879">879</span>
<span id="880">880</span>
<span id="881">881</span>
<span id="882">882</span>
<span id="883">883</span>
<span id="884">884</span>
<span id="885">885</span>
<span id="886">886</span>
<span id="887">887</span>
<span id="888">888</span>
<span id="889">889</span>
<span id="890">890</span>
<span id="891">891</span>
<span id="892">892</span>
<span id="893">893</span>
<span id="894">894</span>
<span id="895">895</span>
<span id="896">896</span>
<span id="897">897</span>
<span id="898">898</span>
<span id="899">899</span>
<span id="900">900</span>
<span id="901">901</span>
<span id="902">902</span>
<span id="903">903</span>
<span id="904">904</span>
<span id="905">905</span>
<span id="906">906</span>
<span id="907">907</span>
<span id="908">908</span>
<span id="909">909</span>
<span id="910">910</span>
<span id="911">911</span>
<span id="912">912</span>
<span id="913">913</span>
<span id="914">914</span>
<span id="915">915</span>
<span id="916">916</span>
<span id="917">917</span>
<span id="918">918</span>
<span id="919">919</span>
<span id="920">920</span>
<span id="921">921</span>
<span id="922">922</span>
<span id="923">923</span>
<span id="924">924</span>
<span id="925">925</span>
<span id="926">926</span>
<span id="927">927</span>
<span id="928">928</span>
<span id="929">929</span>
<span id="930">930</span>
<span id="931">931</span>
<span id="932">932</span>
<span id="933">933</span>
<span id="934">934</span>
<span id="935">935</span>
<span id="936">936</span>
<span id="937">937</span>
<span id="938">938</span>
<span id="939">939</span>
<span id="940">940</span>
<span id="941">941</span>
<span id="942">942</span>
<span id="943">943</span>
<span id="944">944</span>
<span id="945">945</span>
<span id="946">946</span>
<span id="947">947</span>
<span id="948">948</span>
<span id="949">949</span>
<span id="950">950</span>
<span id="951">951</span>
<span id="952">952</span>
<span id="953">953</span>
<span id="954">954</span>
<span id="955">955</span>
<span id="956">956</span>
<span id="957">957</span>
<span id="958">958</span>
<span id="959">959</span>
<span id="960">960</span>
<span id="961">961</span>
<span id="962">962</span>
<span id="963">963</span>
<span id="964">964</span>
<span id="965">965</span>
<span id="966">966</span>
<span id="967">967</span>
<span id="968">968</span>
<span id="969">969</span>
<span id="970">970</span>
<span id="971">971</span>
<span id="972">972</span>
<span id="973">973</span>
<span id="974">974</span>
<span id="975">975</span>
<span id="976">976</span>
<span id="977">977</span>
<span id="978">978</span>
<span id="979">979</span>
<span id="980">980</span>
<span id="981">981</span>
<span id="982">982</span>
<span id="983">983</span>
<span id="984">984</span>
<span id="985">985</span>
<span id="986">986</span>
<span id="987">987</span>
<span id="988">988</span>
<span id="989">989</span>
<span id="990">990</span>
<span id="991">991</span>
<span id="992">992</span>
<span id="993">993</span>
<span id="994">994</span>
<span id="995">995</span>
<span id="996">996</span>
<span id="997">997</span>
<span id="998">998</span>
<span id="999">999</span>
<span id="1000">1000</span>
<span id="1001">1001</span>
<span id="1002">1002</span>
<span id="1003">1003</span>
<span id="1004">1004</span>
<span id="1005">1005</span>
<span id="1006">1006</span>
<span id="1007">1007</span>
<span id="1008">1008</span>
<span id="1009">1009</span>
<span id="1010">1010</span>
<span id="1011">1011</span>
<span id="1012">1012</span>
<span id="1013">1013</span>
<span id="1014">1014</span>
<span id="1015">1015</span>
<span id="1016">1016</span>
<span id="1017">1017</span>
<span id="1018">1018</span>
<span id="1019">1019</span>
<span id="1020">1020</span>
<span id="1021">1021</span>
<span id="1022">1022</span>
<span id="1023">1023</span>
<span id="1024">1024</span>
<span id="1025">1025</span>
<span id="1026">1026</span>
<span id="1027">1027</span>
<span id="1028">1028</span>
<span id="1029">1029</span>
<span id="1030">1030</span>
<span id="1031">1031</span>
<span id="1032">1032</span>
<span id="1033">1033</span>
<span id="1034">1034</span>
<span id="1035">1035</span>
<span id="1036">1036</span>
<span id="1037">1037</span>
<span id="1038">1038</span>
<span id="1039">1039</span>
<span id="1040">1040</span>
<span id="1041">1041</span>
<span id="1042">1042</span>
<span id="1043">1043</span>
<span id="1044">1044</span>
<span id="1045">1045</span>
<span id="1046">1046</span>
<span id="1047">1047</span>
<span id="1048">1048</span>
<span id="1049">1049</span>
<span id="1050">1050</span>
<span id="1051">1051</span>
<span id="1052">1052</span>
<span id="1053">1053</span>
<span id="1054">1054</span>
<span id="1055">1055</span>
<span id="1056">1056</span>
<span id="1057">1057</span>
<span id="1058">1058</span>
<span id="1059">1059</span>
<span id="1060">1060</span>
<span id="1061">1061</span>
<span id="1062">1062</span>
<span id="1063">1063</span>
<span id="1064">1064</span>
<span id="1065">1065</span>
<span id="1066">1066</span>
<span id="1067">1067</span>
<span id="1068">1068</span>
<span id="1069">1069</span>
<span id="1070">1070</span>
<span id="1071">1071</span>
<span id="1072">1072</span>
<span id="1073">1073</span>
<span id="1074">1074</span>
<span id="1075">1075</span>
<span id="1076">1076</span>
<span id="1077">1077</span>
<span id="1078">1078</span>
<span id="1079">1079</span>
<span id="1080">1080</span>
<span id="1081">1081</span>
<span id="1082">1082</span>
<span id="1083">1083</span>
<span id="1084">1084</span>
<span id="1085">1085</span>
<span id="1086">1086</span>
<span id="1087">1087</span>
<span id="1088">1088</span>
<span id="1089">1089</span>
<span id="1090">1090</span>
<span id="1091">1091</span>
<span id="1092">1092</span>
<span id="1093">1093</span>
<span id="1094">1094</span>
<span id="1095">1095</span>
<span id="1096">1096</span>
<span id="1097">1097</span>
<span id="1098">1098</span>
<span id="1099">1099</span>
<span id="1100">1100</span>
<span id="1101">1101</span>
<span id="1102">1102</span>
<span id="1103">1103</span>
<span id="1104">1104</span>
<span id="1105">1105</span>
<span id="1106">1106</span>
<span id="1107">1107</span>
<span id="1108">1108</span>
<span id="1109">1109</span>
<span id="1110">1110</span>
</pre><pre class="rust"><code><span class="doccomment">/*!
Scaling, hinting and rasterization of visual glyph representations.

Scaling is the process of generating an appropriately sized visual
representation of a glyph. The scaler can produce rendered glyph
[images](Image) from outlines, layered color outlines and embedded
bitmaps. Alternatively, you can request raw, optionally hinted
[outlines](Outline) that can then be further processed by [zeno] or
fed into other crates like [lyon](https://github.com/nical/lyon) or
[pathfinder](https://github.com/servo/pathfinder) for tessellation and
GPU rendering.

# Building the scaler

All scaling in this crate takes place within the purview of a
[`ScaleContext`]. This opaque struct manages internal LRU caches and scratch
buffers that are necessary for the scaling process. Generally, you&#39;ll
want to keep an instance with your glyph cache, or if doing multithreaded
glyph rasterization, one instance per thread.

The only method available on the context is [`builder`](ScaleContext::builder)
which takes a type that can be converted into a [`FontRef`] as an argument
and produces a [`ScalerBuilder`] that provides options for configuring and
building a [`Scaler`].

Here, we&#39;ll create a context and build a scaler for a size of 14px with
hinting enabled:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font)
    .size(14.)
    .hint(true)
    .build();
```

You can specify variation settings by calling the [`variations`](ScalerBuilder::variations)
method with an iterator that yields a sequence of values that are convertible
to [`Setting&lt;f32&gt;`]. Tuples of (&amp;str, f32) will work in a pinch. For example,
you can request a variation of the weight axis like this:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font)
    .size(14.)
    .hint(true)
    .variations(&amp;[(&quot;wght&quot;, 520.5)])
    .build();
```

Alternatively, you can specify variations using the
[`normalized_coords`](ScalerBuilder::normalized_coords) method which takes an iterator
that yields [`NormalizedCoord`]s (a type alias for `i16` which is a fixed point value
in 2.14 format). This method is faster than specifying variations by tag and value, but
the difference is likely negligible outside of microbenchmarks. The real advantage
is that a sequence of `i16` is more compact and easier to fold into a key in a glyph
cache. You can compute these normalized coordinates by using the
[`Variation::normalize`](crate::Variation::normalize) method for each available axis in
the font. The best strategy, however, is to simply capture these during shaping with
the [`Shaper::normalized_coords`](crate::shape::Shaper::normalized_coords) method which
will have already computed them for you.

See [`ScalerBuilder`] for available options and default values.

# Outlines and bitmaps

The [`Scaler`] struct essentially provides direct access to the outlines and embedded
bitmaps that are available in the font. In the case of outlines, it can produce the
raw outline in font units or an optionally hinted, scaled outline. For example, to
extract the raw outline for the letter &#39;Q&#39;:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font).build();
let glyph_id = font.charmap().map(&#39;Q&#39;);
let outline = scaler.scale_outline(glyph_id);
```

For the same, but hinted at 12px:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font)
    .hint(true)
    .size(12.)
    .build();
let glyph_id = font.charmap().map(&#39;Q&#39;);
let outline = scaler.scale_outline(glyph_id);
```
The [`scale_outline`](Scaler::scale_outline) method returns an [`Outline`] wrapped
in an option. It will return `None` if an outline was not available or if there was
an error during the scaling process. Note that
[`scale_color_outline`](Scaler::scale_color_outline) can be used to access layered
color outlines such as those included in the Microsoft _Segoe UI Emoji_ font. Finally,
the `_into` variants of these methods ([`scale_outline_into`](Scaler::scale_outline_into)
and [`scale_color_outline_into`](Scaler::scale_color_outline_into)) will return
their results in a previously allocated outline avoiding the extra allocations.

Similar to outlines, bitmaps can be retrieved with the [`scale_bitmap`](Scaler::scale_bitmap)
and [`scale_color_bitmap`](Scaler::scale_color_bitmap) for alpha and color bitmaps,
respectively. These methods return an [`Image`] wrapped in an option. The associated
`_into` variants are also available.

Unlike outlines, bitmaps are available in [`strike`](crate::BitmapStrike)s of various sizes.
When requesting a bitmap, you specify the strategy for strike selection using the
[`StrikeWith`] enum.

For example, if we want the largest available unscaled image for the fire emoji:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font).build();
let glyph_id = font.charmap().map(&#39;🔥&#39;);
let image = scaler.scale_color_bitmap(glyph_id, StrikeWith::LargestSize);
```

Or, to produce a scaled image for a size of 18px:
```
# use swash::{FontRef, CacheKey, scale::*};
# let font: FontRef = FontRef { data: &amp;[], offset: 0, key: CacheKey::new() };
// let font = ...;
let mut context = ScaleContext::new();
let mut scaler = context.builder(font)
    .size(18.)
    .build();
let glyph_id = font.charmap().map(&#39;🔥&#39;);
let image = scaler.scale_color_bitmap(glyph_id, StrikeWith::BestFit);
```
This will select the best strike for the requested size and return
a bitmap that is scaled appropriately for an 18px run of text.

Alpha bitmaps should generally be avoided unless you&#39;re rendering small East
Asian text where these are sometimes still preferred over scalable outlines. In
this case, you should only use [`StrikeWith::ExactSize`] to select the strike,
falling back to an outline if a bitmap is unavailable.

# Rendering

In the general case of text rendering, you&#39;ll likely not care about the specific
details of outlines or bitmaps and will simply want an appropriately sized
image that represents your glyph. For this purpose, you&#39;ll want to use the
[`Render`] struct which is a builder that provides options for rendering an image.
This struct is constructed with a slice of [`Source`]s in priority order and
will iterate through them until it finds one that satisfies the request. Typically,
you&#39;ll want to use the following order:
```
# use swash::scale::*;
Render::new(&amp;[
    // Color outline with the first palette
    Source::ColorOutline(0),
    // Color bitmap with best fit selection mode
    Source::ColorBitmap(StrikeWith::BestFit),
    // Standard scalable outline
    Source::Outline,
]);
```

The [`Render`] struct offers several options that control rasterization of
outlines such as [`format`](Render::format) for selecting a subpixel rendering mode,
[`offset`](Render::offset) for applying fractional positioning, and others. See the
struct documentation for detail.

After selecting your options, call the [`render`](Render::render) method, passing your
configured [`Scaler`] and the requested glyph identifier to produce an [`Image`].
Let&#39;s put it all together by writing a simple function that will render subpixel glyphs
with fractional positioning:
```
# use swash::{scale::{*, image::Image}, FontRef, GlyphId};
fn render_glyph(
    context: &amp;mut ScaleContext,
    font: &amp;FontRef,
    size: f32,
    hint: bool,
    glyph_id: GlyphId,
    x: f32,
    y: f32,
) -&gt; Option&lt;Image&gt; {
    use zeno::{Format, Vector};
    // Build the scaler
    let mut scaler = context.builder(*font).size(size).hint(hint).build();
    // Compute the fractional offset-- you&#39;ll likely want to quantize this
    // in a real renderer
    let offset = Vector::new(x.fract(), y.fract());
    // Select our source order
    Render::new(&amp;[
        Source::ColorOutline(0),
        Source::ColorBitmap(StrikeWith::BestFit),
        Source::Outline,
    ])
    // Select a subpixel format
    .format(Format::Subpixel)
    // Apply the fractional offset
    .offset(offset)
    // Render the image
    .render(&amp;mut scaler, glyph_id)
}
```
Note that rendering also takes care of correctly scaling, rasterizing and
compositing layered color outlines for us.

There are other options available for emboldening, transforming with an
affine matrix, and applying path effects. See the methods on [`Render`] for
more detail.
*/

</span><span class="kw">const </span>TRACE: bool = <span class="bool-val">false</span>;

<span class="kw">pub mod </span>image;
<span class="kw">pub mod </span>outline;

<span class="kw">mod </span>bitmap;
<span class="kw">mod </span>cff;
<span class="kw">mod </span>color;
<span class="kw">mod </span>glyf;
<span class="kw">mod </span>proxy;

<span class="kw">use </span>image::<span class="kw-2">*</span>;
<span class="kw">use </span>outline::<span class="kw-2">*</span>;

<span class="kw">use </span><span class="kw">super</span>::internal;
<span class="kw">use super</span>::{cache::FontCache, setting::Setting, FontRef, GlyphId, NormalizedCoord};
<span class="kw">use </span>core::borrow::Borrow;
<span class="kw">use </span>proxy::<span class="kw-2">*</span>;
<span class="attribute">#[cfg(feature = <span class="string">&quot;render&quot;</span>)]
</span><span class="kw">use </span>zeno::{Format, Mask, Origin, Scratch, Style, Transform, Vector};
<span class="kw">use </span>zeno::{Placement, Point};

<span class="kw">pub</span>(<span class="kw">crate</span>) <span class="kw">use </span>bitmap::decode_png;

<span class="doccomment">/// Index of a color palette.
</span><span class="kw">pub type </span>PaletteIndex = u16;

<span class="doccomment">/// Index of a bitmap strike.
</span><span class="kw">pub type </span>StrikeIndex = u32;

<span class="doccomment">/// Bitmap strike selection mode.
</span><span class="attribute">#[derive(Copy, Clone, Debug)]
</span><span class="kw">pub enum </span>StrikeWith {
    <span class="doccomment">/// Load a bitmap only if the exact size is available.
    </span>ExactSize,
    <span class="doccomment">/// Load a bitmap of the best available size.
    </span>BestFit,
    <span class="doccomment">/// Loads a bitmap of the largest size available.
    </span>LargestSize,
    <span class="doccomment">/// Load a bitmap from the specified strike.
    </span>Index(StrikeIndex),
}

<span class="doccomment">/// Glyph sources for the renderer.
</span><span class="attribute">#[derive(Copy, Clone, Debug)]
</span><span class="kw">pub enum </span>Source {
    <span class="doccomment">/// Scalable outlines.
    </span>Outline,
    <span class="doccomment">/// Layered color scalable outlines.
    </span>ColorOutline(PaletteIndex),
    <span class="doccomment">/// Embedded alpha bitmaps.
    </span>Bitmap(StrikeWith),
    <span class="doccomment">/// Embedded color bitmaps.
    </span>ColorBitmap(StrikeWith),
}

<span class="kw">impl </span>Default <span class="kw">for </span>Source {
    <span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::Outline
    }
}

<span class="doccomment">/// Context that manages caches and scratch buffers for scaling.
///
/// See the module level [documentation](index.html#building-the-scaler) for detail.
</span><span class="kw">pub struct </span>ScaleContext {
    fonts: FontCache&lt;ScalerProxy&gt;,
    state: State,
    coords: Vec&lt;i16&gt;,
}

<span class="kw">struct </span>State {
    glyf_scaler: glyf::Scaler,
    cff_scaler: cff::Scaler,
    scratch0: Vec&lt;u8&gt;,
    scratch1: Vec&lt;u8&gt;,
    outline: Outline,
    <span class="attribute">#[cfg(feature = <span class="string">&quot;render&quot;</span>)]
    </span>rcx: Scratch,
}

<span class="kw">impl </span>ScaleContext {
    <span class="doccomment">/// Creates a new scaling context.
    </span><span class="kw">pub fn </span>new() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::with_max_entries(<span class="number">8</span>)
    }

    <span class="doccomment">/// Creates a new scaling context with the specified maximum number of
    /// cache entries.
    </span><span class="kw">pub fn </span>with_max_entries(max_entries: usize) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span>max_entries = max_entries.min(<span class="number">64</span>).max(<span class="number">1</span>);
        <span class="self">Self </span>{
            fonts: FontCache::new(max_entries),
            state: State {
                glyf_scaler: glyf::Scaler::new(max_entries),
                cff_scaler: cff::Scaler::new(max_entries),
                scratch0: Vec::new(),
                scratch1: Vec::new(),
                outline: Outline::new(),
                <span class="attribute">#[cfg(feature = <span class="string">&quot;render&quot;</span>)]
                </span>rcx: Scratch::new(),
            },
            coords: Vec::new(),
        }
    }

    <span class="doccomment">/// Creates a new builder for constructing a scaler with this context
    /// and the specified font.
    </span><span class="kw">pub fn </span>builder&lt;<span class="lifetime">&#39;a</span>&gt;(<span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span><span class="self">self</span>, font: <span class="kw">impl </span>Into&lt;FontRef&lt;<span class="lifetime">&#39;a</span>&gt;&gt;) -&gt; ScalerBuilder&lt;<span class="lifetime">&#39;a</span>&gt; {
        ScalerBuilder::new(<span class="self">self</span>, font)
    }
}

<span class="kw">impl </span>Default <span class="kw">for </span>ScaleContext {
    <span class="kw">fn </span>default() -&gt; <span class="self">Self </span>{
        <span class="self">Self</span>::new()
    }
}

<span class="doccomment">/// Builder for configuring a scaler.
</span><span class="kw">pub struct </span>ScalerBuilder&lt;<span class="lifetime">&#39;a</span>&gt; {
    state: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>State,
    font: FontRef&lt;<span class="lifetime">&#39;a</span>&gt;,
    proxy: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>ScalerProxy,
    id: u64,
    coords: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>Vec&lt;i16&gt;,
    size: f32,
    hint: bool,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; ScalerBuilder&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="kw">fn </span>new(context: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>ScaleContext, font: <span class="kw">impl </span>Into&lt;FontRef&lt;<span class="lifetime">&#39;a</span>&gt;&gt;) -&gt; <span class="self">Self </span>{
        <span class="kw">let </span>font = font.into();
        <span class="kw">let </span>(id, proxy) = context
            .fonts
            .get(<span class="kw-2">&amp;</span>font, |font| ScalerProxy::from_font(font));
        <span class="self">Self </span>{
            state: <span class="kw-2">&amp;mut </span>context.state,
            font,
            proxy,
            id,
            coords: <span class="kw-2">&amp;mut </span>context.coords,
            size: <span class="number">0.</span>,
            hint: <span class="bool-val">false</span>,
        }
    }

    <span class="doccomment">/// Specifies the font size in pixels per em. The default value is `0` which will produce
    /// unscaled glyphs in original font units.
    </span><span class="kw">pub fn </span>size(<span class="kw-2">mut </span><span class="self">self</span>, ppem: f32) -&gt; <span class="self">Self </span>{
        <span class="self">self</span>.size = ppem.max(<span class="number">0.</span>);
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies whether to apply hinting to outlines. The default value is `false`.
    </span><span class="kw">pub fn </span>hint(<span class="kw-2">mut </span><span class="self">self</span>, yes: bool) -&gt; <span class="self">Self </span>{
        <span class="self">self</span>.hint = yes;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Adds variation settings to the scaler.
    </span><span class="kw">pub fn </span>variations&lt;I&gt;(<span class="self">self</span>, settings: I) -&gt; <span class="self">Self
    </span><span class="kw">where
        </span>I: IntoIterator,
        I::Item: Into&lt;Setting&lt;f32&gt;&gt;,
    {
        <span class="kw">if </span><span class="self">self</span>.proxy.coord_count != <span class="number">0 </span>{
            <span class="kw">let </span>vars = <span class="self">self</span>.font.variations();
            <span class="self">self</span>.coords.resize(vars.len(), <span class="number">0</span>);
            <span class="kw">for </span>setting <span class="kw">in </span>settings {
                <span class="kw">let </span>setting = setting.into();
                <span class="kw">for </span>var <span class="kw">in </span>vars {
                    <span class="kw">if </span>var.tag() == setting.tag {
                        <span class="kw">let </span>value = var.normalize(setting.value);
                        <span class="kw">if let </span><span class="prelude-val">Some</span>(c) = <span class="self">self</span>.coords.get_mut(var.index()) {
                            <span class="kw-2">*</span>c = value;
                        }
                    }
                }
            }
        }
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies the variation settings in terms of normalized coordinates. This will replace
    /// any previous variation settings.
    </span><span class="kw">pub fn </span>normalized_coords&lt;I&gt;(<span class="self">self</span>, coords: I) -&gt; <span class="self">Self
    </span><span class="kw">where
        </span>I: IntoIterator,
        I::Item: Borrow&lt;NormalizedCoord&gt;,
    {
        <span class="self">self</span>.coords.clear();
        <span class="self">self</span>.coords.extend(coords.into_iter().map(|c| <span class="kw-2">*</span>c.borrow()));
        <span class="self">self
    </span>}

    <span class="doccomment">/// Builds a scaler for the current configuration.
    </span><span class="kw">pub fn </span>build(<span class="self">self</span>) -&gt; Scaler&lt;<span class="lifetime">&#39;a</span>&gt; {
        <span class="kw">let </span>upem = <span class="self">self</span>.proxy.metrics.units_per_em();
        <span class="kw">let </span>scale = <span class="kw">if </span><span class="self">self</span>.size != <span class="number">0. </span>&amp;&amp; upem != <span class="number">0 </span>{
            <span class="self">self</span>.size / upem <span class="kw">as </span>f32
        } <span class="kw">else </span>{
            <span class="number">1.
        </span>};
        Scaler {
            state: <span class="self">self</span>.state,
            font: <span class="self">self</span>.font,
            proxy: <span class="self">self</span>.proxy,
            id: <span class="self">self</span>.id,
            coords: <span class="kw-2">&amp;</span><span class="self">self</span>.coords[..],
            size: <span class="self">self</span>.size,
            scale,
            hint: <span class="self">self</span>.hint,
            glyf_state: <span class="prelude-val">None</span>,
        }
    }
}

<span class="doccomment">/// Scales outline and bitmap glyphs.
///
/// See the module level [documentation](index.html#outlines-and-bitmaps) for detail.
</span><span class="kw">pub struct </span>Scaler&lt;<span class="lifetime">&#39;a</span>&gt; {
    state: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>State,
    font: FontRef&lt;<span class="lifetime">&#39;a</span>&gt;,
    proxy: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>ScalerProxy,
    id: u64,
    coords: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[i16],
    size: f32,
    scale: f32,
    hint: bool,
    glyf_state: <span class="prelude-ty">Option</span>&lt;glyf::ScalerState&lt;<span class="lifetime">&#39;a</span>&gt;&gt;,
}

<span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Scaler&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="doccomment">/// Returns true if scalable glyph outlines are available.
    </span><span class="kw">pub fn </span>has_outlines(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        !<span class="macro">matches!</span>(<span class="self">self</span>.proxy.outlines, OutlinesProxy::None)
    }

    <span class="doccomment">/// Scales an outline for the specified glyph into the provided outline.
    </span><span class="kw">pub fn </span>scale_outline_into(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: GlyphId, outline: <span class="kw-2">&amp;mut </span>Outline) -&gt; bool {
        outline.clear();
        <span class="self">self</span>.scale_outline_impl(glyph_id, <span class="prelude-val">None</span>, <span class="prelude-val">Some</span>(outline))
    }

    <span class="doccomment">/// Scales an outline for the specified glyph.
    </span><span class="kw">pub fn </span>scale_outline(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: GlyphId) -&gt; <span class="prelude-ty">Option</span>&lt;Outline&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>outline = Outline::new();
        <span class="kw">if </span><span class="self">self</span>.scale_outline_into(glyph_id, <span class="kw-2">&amp;mut </span>outline) {
            <span class="prelude-val">Some</span>(outline)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }

    <span class="doccomment">/// Returns true if scalable color glyph outlines are available.
    </span><span class="kw">pub fn </span>has_color_outlines(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.proxy.color.colr != <span class="number">0 </span>&amp;&amp; <span class="self">self</span>.proxy.color.cpal != <span class="number">0
    </span>}

    <span class="doccomment">/// Scales a color outline for the specified glyph into the provided outline.
    </span><span class="kw">pub fn </span>scale_color_outline_into(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: GlyphId, outline: <span class="kw-2">&amp;mut </span>Outline) -&gt; bool {
        outline.clear();
        <span class="kw">if </span>!<span class="self">self</span>.has_color_outlines() {
            <span class="kw">return </span><span class="bool-val">false</span>;
        }
        <span class="kw">let </span>layers = <span class="kw">match </span><span class="self">self</span>.proxy.color.layers(<span class="self">self</span>.font.data, glyph_id) {
            <span class="prelude-val">Some</span>(layers) =&gt; layers,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="bool-val">false</span>,
        };
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..layers.len() {
            <span class="kw">let </span>layer = <span class="kw">match </span>layers.get(i) {
                <span class="prelude-val">Some</span>(layer) =&gt; layer,
                <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="bool-val">false</span>,
            };
            <span class="kw">if </span>!<span class="self">self</span>.scale_outline_impl(layer.glyph_id, layer.color_index, <span class="prelude-val">Some</span>(outline)) {
                <span class="kw">return </span><span class="bool-val">false</span>;
            }
        }
        outline.set_color(<span class="bool-val">true</span>);
        <span class="bool-val">true
    </span>}

    <span class="doccomment">/// Scales a color outline for the specified glyph.
    </span><span class="kw">pub fn </span>scale_color_outline(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: GlyphId) -&gt; <span class="prelude-ty">Option</span>&lt;Outline&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>outline = Outline::new();
        <span class="kw">if </span><span class="self">self</span>.scale_color_outline_into(glyph_id, <span class="kw-2">&amp;mut </span>outline) {
            <span class="prelude-val">Some</span>(outline)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }

    <span class="kw">fn </span>scale_outline_impl(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        glyph_id: GlyphId,
        color_index: <span class="prelude-ty">Option</span>&lt;u16&gt;,
        outline: <span class="prelude-ty">Option</span>&lt;<span class="kw-2">&amp;mut </span>Outline&gt;,
    ) -&gt; bool {
        <span class="kw">let </span>outline = <span class="kw">match </span>outline {
            <span class="prelude-val">Some</span>(x) =&gt; x,
            <span class="kw">_ </span>=&gt; <span class="kw-2">&amp;mut </span><span class="self">self</span>.state.outline,
        };
        <span class="kw">match </span><span class="kw-2">&amp;</span><span class="self">self</span>.proxy.outlines {
            OutlinesProxy::None =&gt; <span class="bool-val">false</span>,
            OutlinesProxy::Cff(proxy) =&gt; {
                outline.begin_layer(color_index);
                <span class="kw">let </span><span class="kw-2">mut </span>builder = CffBuilder { outline };
                <span class="kw">if </span><span class="self">self
                    </span>.state
                    .cff_scaler
                    .scale(
                        <span class="kw-2">&amp;</span><span class="self">self</span>.font,
                        <span class="self">self</span>.id,
                        <span class="kw-2">&amp;</span><span class="self">self</span>.coords,
                        proxy,
                        <span class="self">self</span>.scale,
                        <span class="self">self</span>.hint,
                        glyph_id,
                        <span class="kw-2">&amp;mut </span>builder,
                    )
                    .is_some()
                {
                    outline.maybe_close();
                    outline.finish();
                    <span class="bool-val">true
                </span>} <span class="kw">else </span>{
                    <span class="bool-val">false
                </span>}
            }
            OutlinesProxy::Glyf(proxy) =&gt; {
                <span class="kw">if </span><span class="self">self</span>.glyf_state.is_none() {
                    <span class="self">self</span>.glyf_state = <span class="prelude-val">Some</span>(glyf::ScalerState::new(
                        <span class="self">self</span>.font.data,
                        <span class="self">self</span>.id,
                        <span class="kw-2">&amp;</span><span class="self">self</span>.coords,
                        proxy,
                        <span class="kw-2">&amp;</span><span class="self">self</span>.proxy.metrics,
                        <span class="self">self</span>.size,
                        <span class="self">self</span>.hint,
                    ));
                }
                <span class="kw">let </span>state = <span class="self">self</span>.glyf_state.as_mut().unwrap();
                outline.begin_layer(color_index);
                <span class="kw">if </span><span class="self">self</span>.state.glyf_scaler.scale(state, glyph_id).is_some() {
                    <span class="kw">let </span>scaler = <span class="kw-2">&amp;</span><span class="self">self</span>.state.glyf_scaler;
                    fill_outline(
                        outline,
                        <span class="kw-2">&amp;</span>scaler.scaled,
                        <span class="kw-2">&amp;</span>scaler.contours,
                        <span class="kw-2">&amp;</span>scaler.tags,
                        <span class="self">self</span>.size != <span class="number">0.</span>,
                    );
                    outline.maybe_close();
                    outline.finish();
                    <span class="bool-val">true
                </span>} <span class="kw">else </span>{
                    <span class="bool-val">false
                </span>}
            }
        }
    }

    <span class="comment">// Unused when render feature is disabled.
    </span><span class="attribute">#[allow(dead_code)]
    </span><span class="kw">fn </span>scale_color_outline_impl(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: GlyphId) -&gt; bool {
        <span class="kw">if </span>!<span class="self">self</span>.has_color_outlines() {
            <span class="kw">return </span><span class="bool-val">false</span>;
        }
        <span class="kw">let </span>layers = <span class="kw">match </span><span class="self">self</span>.proxy.color.layers(<span class="self">self</span>.font.data, glyph_id) {
            <span class="prelude-val">Some</span>(layers) =&gt; layers,
            <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="bool-val">false</span>,
        };
        <span class="self">self</span>.state.outline.clear();
        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..layers.len() {
            <span class="kw">let </span>layer = <span class="kw">match </span>layers.get(i) {
                <span class="prelude-val">Some</span>(layer) =&gt; layer,
                <span class="kw">_ </span>=&gt; <span class="kw">return </span><span class="bool-val">false</span>,
            };
            <span class="kw">if </span>!<span class="self">self</span>.scale_outline_impl(layer.glyph_id, layer.color_index, <span class="prelude-val">None</span>) {
                <span class="kw">return </span><span class="bool-val">false</span>;
            }
        }
        <span class="bool-val">true
    </span>}

    <span class="doccomment">/// Returns true if alpha bitmaps are available.
    </span><span class="kw">pub fn </span>has_bitmaps(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.proxy.bitmaps.has_alpha()
    }

    <span class="doccomment">/// Scales a bitmap for the specified glyph and mode into the provided image.
    </span><span class="kw">pub fn </span>scale_bitmap_into(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        glyph_id: u16,
        strike: StrikeWith,
        image: <span class="kw-2">&amp;mut </span>Image,
    ) -&gt; bool {
        <span class="self">self</span>.scale_bitmap_impl(glyph_id, <span class="bool-val">false</span>, strike, image) == <span class="prelude-val">Some</span>(<span class="bool-val">true</span>)
    }

    <span class="doccomment">/// Scales a bitmap for the specified glyph and mode.
    </span><span class="kw">pub fn </span>scale_bitmap(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: u16, strike: StrikeWith) -&gt; <span class="prelude-ty">Option</span>&lt;Image&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>image = Image::new();
        <span class="kw">if </span><span class="self">self</span>.scale_bitmap_into(glyph_id, strike, <span class="kw-2">&amp;mut </span>image) {
            <span class="prelude-val">Some</span>(image)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }

    <span class="doccomment">/// Returns true if color bitmaps are available.
    </span><span class="kw">pub fn </span>has_color_bitmaps(<span class="kw-2">&amp;</span><span class="self">self</span>) -&gt; bool {
        <span class="self">self</span>.proxy.bitmaps.has_color()
    }

    <span class="doccomment">/// Scales a color bitmap for the specified glyph and mode into the provided image.
    </span><span class="kw">pub fn </span>scale_color_bitmap_into(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        glyph_id: u16,
        strike: StrikeWith,
        image: <span class="kw-2">&amp;mut </span>Image,
    ) -&gt; bool {
        <span class="self">self</span>.scale_bitmap_impl(glyph_id, <span class="bool-val">true</span>, strike, image) == <span class="prelude-val">Some</span>(<span class="bool-val">true</span>)
    }

    <span class="doccomment">/// Scales a color bitmap for the specified glyph and mode.
    </span><span class="kw">pub fn </span>scale_color_bitmap(<span class="kw-2">&amp;mut </span><span class="self">self</span>, glyph_id: u16, strike: StrikeWith) -&gt; <span class="prelude-ty">Option</span>&lt;Image&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>image = Image::new();
        <span class="kw">if </span><span class="self">self</span>.scale_color_bitmap_into(glyph_id, strike, <span class="kw-2">&amp;mut </span>image) {
            <span class="prelude-val">Some</span>(image)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }

    <span class="kw">fn </span>scale_bitmap_impl(
        <span class="kw-2">&amp;mut </span><span class="self">self</span>,
        glyph_id: GlyphId,
        color: bool,
        strike: StrikeWith,
        image: <span class="kw-2">&amp;mut </span>Image,
    ) -&gt; <span class="prelude-ty">Option</span>&lt;bool&gt; {
        image.clear();
        <span class="kw">let </span>size = <span class="self">self</span>.size;
        <span class="kw">let </span><span class="kw-2">mut </span>strikes = <span class="kw">if </span>color {
            <span class="self">self</span>.proxy.bitmaps.materialize_color(<span class="kw-2">&amp;</span><span class="self">self</span>.font)
        } <span class="kw">else </span>{
            <span class="self">self</span>.proxy.bitmaps.materialize_alpha(<span class="kw-2">&amp;</span><span class="self">self</span>.font)
        };
        <span class="kw">let </span>bitmap = <span class="kw">match </span>strike {
            StrikeWith::ExactSize =&gt; {
                <span class="kw">if </span><span class="self">self</span>.size == <span class="number">0. </span>{
                    <span class="prelude-val">None
                </span>} <span class="kw">else </span>{
                    strikes
                        .find_by_exact_ppem(size <span class="kw">as </span>u16, glyph_id)<span class="question-mark">?
                        </span>.get(glyph_id)
                }
            }
            StrikeWith::BestFit =&gt; {
                <span class="kw">if </span><span class="self">self</span>.size == <span class="number">0. </span>{
                    <span class="prelude-val">None
                </span>} <span class="kw">else </span>{
                    strikes
                        .find_by_nearest_ppem(size <span class="kw">as </span>u16, glyph_id)<span class="question-mark">?
                        </span>.get(glyph_id)
                }
            }
            StrikeWith::LargestSize =&gt; strikes.find_by_largest_ppem(glyph_id)<span class="question-mark">?</span>.get(glyph_id),
            StrikeWith::Index(i) =&gt; strikes
                .nth(i <span class="kw">as </span>usize)
                .and_then(|strike| strike.get(glyph_id)),
        }<span class="question-mark">?</span>;
        <span class="kw">if </span>bitmap.ppem == <span class="number">0 </span>{
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span>(<span class="kw">_</span>, <span class="kw">_</span>, bufsize) = bitmap.scaled_size(size);
        image.data.resize(bufsize, <span class="number">0</span>);
        <span class="self">self</span>.state.scratch0.clear();
        <span class="self">self</span>.state.scratch1.clear();
        <span class="kw">let </span><span class="kw-2">mut </span>w = bitmap.width;
        <span class="kw">let </span><span class="kw-2">mut </span>h = bitmap.height;
        <span class="kw">let </span>scale = size / bitmap.ppem <span class="kw">as </span>f32;
        image.placement = <span class="kw">if </span>size != <span class="number">0. </span>&amp;&amp; scale != <span class="number">1. </span>{
            <span class="self">self</span>.state
                .scratch0
                .resize(bitmap.format.buffer_size(w, h), <span class="number">0</span>);
            w = (w <span class="kw">as </span>f32 * scale) <span class="kw">as </span>u32;
            h = (h <span class="kw">as </span>f32 * scale) <span class="kw">as </span>u32;
            image.data.resize(bitmap.format.buffer_size(w, h), <span class="number">0</span>);
            <span class="kw">if </span>!bitmap.decode(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="self">self</span>.state.scratch1), <span class="kw-2">&amp;mut </span><span class="self">self</span>.state.scratch0) {
                <span class="kw">return </span><span class="prelude-val">None</span>;
            }
            <span class="kw">if </span>!bitmap::resize(
                <span class="kw-2">&amp;</span><span class="self">self</span>.state.scratch0,
                bitmap.width,
                bitmap.height,
                bitmap.format.channels(),
                <span class="kw-2">&amp;mut </span>image.data,
                w,
                h,
                bitmap::Filter::Mitchell,
                <span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="self">self</span>.state.scratch1),
            ) {
                <span class="kw">return </span><span class="prelude-val">None</span>;
            }
            <span class="kw">let </span>left = (bitmap.left <span class="kw">as </span>f32 * scale) <span class="kw">as </span>i32;
            <span class="kw">let </span>top = (bitmap.top <span class="kw">as </span>f32 * scale) <span class="kw">as </span>i32;
            Placement {
                left,
                top,
                width: w,
                height: h,
            }
        } <span class="kw">else </span>{
            image.data.resize(bitmap.format.buffer_size(w, h), <span class="number">0</span>);
            <span class="kw">if </span>!bitmap.decode(<span class="prelude-val">Some</span>(<span class="kw-2">&amp;mut </span><span class="self">self</span>.state.scratch1), <span class="kw-2">&amp;mut </span>image.data) {
                <span class="kw">return </span><span class="prelude-val">None</span>;
            }
            Placement {
                left: bitmap.left,
                top: bitmap.top,
                width: w,
                height: h,
            }
        };
        image.source = <span class="kw">match </span>color {
            <span class="bool-val">true </span>=&gt; Source::ColorBitmap(strike),
            <span class="bool-val">false </span>=&gt; Source::Bitmap(strike),
        };
        image.content = <span class="kw">match </span>bitmap.format.channels() {
            <span class="number">1 </span>=&gt; Content::Mask,
            <span class="kw">_ </span>=&gt; Content::Color,
        };
        <span class="comment">// let mut advance = bitmap.advance() as f32;
        // if options.size != 0. &amp;&amp; options.size as u16 != bitmap.ppem() {
        //     advance *= options.size / bitmap.ppem() as f32;
        // }
        </span><span class="prelude-val">Some</span>(<span class="bool-val">true</span>)
    }
}

<span class="doccomment">/// Builder type for rendering a glyph into an image.
///
/// See the module level [documentation](index.html#rendering) for detail.
</span><span class="attribute">#[cfg(feature = <span class="string">&quot;render&quot;</span>)]
</span><span class="kw">pub struct </span>Render&lt;<span class="lifetime">&#39;a</span>&gt; {
    sources: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[Source],
    format: Format,
    offset: Point,
    transform: <span class="prelude-ty">Option</span>&lt;Transform&gt;,
    embolden: f32,
    foreground: [u8; <span class="number">4</span>],
    style: Style&lt;<span class="lifetime">&#39;a</span>&gt;,
}

<span class="attribute">#[cfg(feature = <span class="string">&quot;render&quot;</span>)]
</span><span class="kw">impl</span>&lt;<span class="lifetime">&#39;a</span>&gt; Render&lt;<span class="lifetime">&#39;a</span>&gt; {
    <span class="doccomment">/// Creates a new builder for configuring rendering using the specified
    /// prioritized list of sources.
    </span><span class="kw">pub fn </span>new(sources: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span>[Source]) -&gt; <span class="self">Self </span>{
        <span class="self">Self </span>{
            sources,
            format: Format::Alpha,
            offset: Point::new(<span class="number">0.</span>, <span class="number">0.</span>),
            transform: <span class="prelude-val">None</span>,
            embolden: <span class="number">0.</span>,
            foreground: [<span class="number">128</span>, <span class="number">128</span>, <span class="number">128</span>, <span class="number">255</span>],
            style: Style::default(),
        }
    }

    <span class="doccomment">/// Specifies the target format for rasterizing an outline. Default is
    /// [`Format::Alpha`](zeno::Format::Alpha).
    </span><span class="kw">pub fn </span>format(<span class="kw-2">&amp;mut </span><span class="self">self</span>, format: Format) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.format = format;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies the path style to use when rasterizing an outline. Default is
    /// [`Fill::NonZero`](zeno::Fill::NonZero).
    </span><span class="kw">pub fn </span>style(<span class="kw-2">&amp;mut </span><span class="self">self</span>, style: <span class="kw">impl </span>Into&lt;Style&lt;<span class="lifetime">&#39;a</span>&gt;&gt;) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.style = style.into();
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies an additional offset to apply when rasterizing an outline.
    /// Default is `(0, 0)`.
    </span><span class="kw">pub fn </span>offset(<span class="kw-2">&amp;mut </span><span class="self">self</span>, offset: Vector) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.offset = offset;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies a transformation matrix to apply when rasterizing an
    /// outline. Default is `None`.
    </span><span class="kw">pub fn </span>transform(<span class="kw-2">&amp;mut </span><span class="self">self</span>, transform: <span class="prelude-ty">Option</span>&lt;Transform&gt;) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.transform = transform;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies the strength of a faux bold transform to apply when
    /// rasterizing an outline. Default is `0`.
    </span><span class="kw">pub fn </span>embolden(<span class="kw-2">&amp;mut </span><span class="self">self</span>, strength: f32) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.embolden = strength;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Specifies an RGBA color to use when rasterizing layers of a color
    /// outline that do not directly reference a palette color. Default is
    /// `[128, 128, 128, 255]`.
    </span><span class="kw">pub fn </span>default_color(<span class="kw-2">&amp;mut </span><span class="self">self</span>, color: [u8; <span class="number">4</span>]) -&gt; <span class="kw-2">&amp;mut </span><span class="self">Self </span>{
        <span class="self">self</span>.foreground = color;
        <span class="self">self
    </span>}

    <span class="doccomment">/// Renders the specified glyph using the current configuration into the
    /// provided image.
    </span><span class="kw">pub fn </span>render_into(<span class="kw-2">&amp;</span><span class="self">self</span>, scaler: <span class="kw-2">&amp;mut </span>Scaler, glyph_id: GlyphId, image: <span class="kw-2">&amp;mut </span>Image) -&gt; bool {
        <span class="kw">for </span>source <span class="kw">in </span><span class="self">self</span>.sources {
            <span class="kw">match </span>source {
                Source::Outline =&gt; {
                    <span class="kw">if </span>!scaler.has_outlines() {
                        <span class="kw">continue</span>;
                    }
                    scaler.state.outline.clear();
                    <span class="kw">if </span>scaler.scale_outline_impl(glyph_id, <span class="prelude-val">None</span>, <span class="prelude-val">None</span>) {
                        <span class="kw">let </span>state = <span class="kw-2">&amp;mut </span>scaler.state;
                        <span class="kw">let </span>rcx = <span class="kw-2">&amp;mut </span>state.rcx;
                        <span class="kw">let </span>outline = <span class="kw-2">&amp;mut </span>state.outline;
                        <span class="kw">if </span><span class="self">self</span>.embolden != <span class="number">0. </span>{
                            outline.embolden(<span class="self">self</span>.embolden, <span class="self">self</span>.embolden);
                        }
                        <span class="kw">if let </span><span class="prelude-val">Some</span>(transform) = <span class="kw-2">&amp;</span><span class="self">self</span>.transform {
                            outline.transform(transform);
                        }
                        <span class="kw">let </span>placement = Mask::with_scratch(outline.path(), rcx)
                            .format(<span class="self">self</span>.format)
                            .origin(Origin::BottomLeft)
                            .style(<span class="self">self</span>.style)
                            .render_offset(<span class="self">self</span>.offset)
                            .inspect(|fmt, w, h| {
                                image.data.resize(fmt.buffer_size(w, h), <span class="number">0</span>);
                            })
                            .render_into(<span class="kw-2">&amp;mut </span>image.data[..], <span class="prelude-val">None</span>);
                        image.placement = placement;
                        image.content = <span class="kw">if </span><span class="self">self</span>.format == Format::Alpha {
                            Content::Mask
                        } <span class="kw">else </span>{
                            Content::SubpixelMask
                        };
                        image.source = Source::Outline;
                        <span class="kw">return </span><span class="bool-val">true</span>;
                    }
                }
                Source::ColorOutline(palette_index) =&gt; {
                    <span class="kw">if </span>!scaler.has_color_outlines() {
                        <span class="kw">continue</span>;
                    }
                    scaler.state.outline.clear();
                    <span class="kw">if </span>scaler.scale_color_outline_impl(glyph_id) {
                        <span class="kw">let </span>font = <span class="kw-2">&amp;</span>scaler.font;
                        <span class="kw">let </span>proxy = <span class="kw-2">&amp;</span>scaler.proxy;
                        <span class="kw">let </span>state = <span class="kw-2">&amp;mut </span>scaler.state;
                        <span class="kw">let </span>scratch = <span class="kw-2">&amp;mut </span>state.scratch0;
                        <span class="kw">let </span>rcx = <span class="kw-2">&amp;mut </span>state.rcx;
                        <span class="kw">let </span>outline = <span class="kw-2">&amp;mut </span>state.outline;
                        <span class="comment">// Cool effect, but probably not generally desirable.
                        // Maybe expose a separate option?
                        // if self.embolden != 0. {
                        //     outline.embolden(self.embolden, self.embolden);
                        // }
                        </span><span class="kw">if let </span><span class="prelude-val">Some</span>(transform) = <span class="kw-2">&amp;</span><span class="self">self</span>.transform {
                            outline.transform(transform);
                        }
                        <span class="kw">let </span>palette = proxy.color.palette(font, <span class="kw-2">*</span>palette_index);

                        <span class="kw">let </span>total_bounds = outline.bounds();

                        <span class="kw">let </span>base_x = total_bounds.min.x.floor() <span class="kw">as </span>i32;
                        <span class="kw">let </span>base_y = total_bounds.min.y.floor() <span class="kw">as </span>i32;
                        <span class="kw">let </span>base_w = total_bounds.width().ceil() <span class="kw">as </span>u32;
                        <span class="kw">let </span>base_h = total_bounds.height().ceil() <span class="kw">as </span>u32;

                        image.data.resize((base_w * base_h * <span class="number">4</span>) <span class="kw">as </span>usize, <span class="number">0</span>);
                        image.placement.left = base_x;
                        image.placement.top = base_h <span class="kw">as </span>i32 + base_y;
                        image.placement.width = total_bounds.width().ceil() <span class="kw">as </span>u32;
                        image.placement.height = total_bounds.height().ceil() <span class="kw">as </span>u32;

                        <span class="kw">let </span><span class="kw-2">mut </span>ok = <span class="bool-val">true</span>;
                        <span class="kw">for </span>i <span class="kw">in </span><span class="number">0</span>..outline.len() {
                            <span class="kw">let </span>layer = <span class="kw">match </span>outline.get(i) {
                                <span class="prelude-val">Some</span>(layer) =&gt; layer,
                                <span class="kw">_ </span>=&gt; {
                                    ok = <span class="bool-val">false</span>;
                                    <span class="kw">break</span>;
                                }
                            };

                            scratch.clear();
                            <span class="kw">let </span>placement = Mask::with_scratch(layer.path(), rcx)
                                .origin(Origin::BottomLeft)
                                .style(<span class="self">self</span>.style)
                                .render_offset(<span class="self">self</span>.offset)
                                .inspect(|fmt, w, h| {
                                    scratch.resize(fmt.buffer_size(w, h), <span class="number">0</span>);
                                })
                                .render_into(<span class="kw-2">&amp;mut </span>scratch[..], <span class="prelude-val">None</span>);
                            <span class="kw">let </span>color = layer
                                .color_index()
                                .map(|i| palette.map(|p| p.get(i)))
                                .flatten()
                                .unwrap_or(<span class="self">self</span>.foreground);
                            bitmap::blit(
                                <span class="kw-2">&amp;</span>scratch[..],
                                placement.width,
                                placement.height,
                                placement.left.wrapping_sub(base_x),
                                (base_h <span class="kw">as </span>i32 + base_y).wrapping_sub(placement.top),
                                color,
                                <span class="kw-2">&amp;mut </span>image.data,
                                base_w,
                                base_h,
                            );
                        }
                        <span class="kw">if </span>ok {
                            image.source = Source::ColorOutline(<span class="kw-2">*</span>palette_index);
                            image.content = Content::Color;
                            <span class="kw">return </span><span class="bool-val">true</span>;
                        }
                    }
                }
                Source::Bitmap(mode) =&gt; {
                    <span class="kw">if </span>!scaler.has_bitmaps() {
                        <span class="kw">continue</span>;
                    }
                    <span class="kw">if </span>scaler.scale_bitmap_into(glyph_id, <span class="kw-2">*</span>mode, image) {
                        <span class="kw">return </span><span class="bool-val">true</span>;
                    }
                }
                Source::ColorBitmap(mode) =&gt; {
                    <span class="kw">if </span>!scaler.has_color_bitmaps() {
                        <span class="kw">continue</span>;
                    }
                    <span class="kw">if </span>scaler.scale_color_bitmap_into(glyph_id, <span class="kw-2">*</span>mode, image) {
                        <span class="kw">return </span><span class="bool-val">true</span>;
                    }
                }
            }
        }
        <span class="bool-val">false
    </span>}

    <span class="doccomment">/// Renders the specified glyph using the current configuration.
    </span><span class="kw">pub fn </span>render(<span class="kw-2">&amp;</span><span class="self">self</span>, scaler: <span class="kw-2">&amp;mut </span>Scaler, glyph_id: GlyphId) -&gt; <span class="prelude-ty">Option</span>&lt;Image&gt; {
        <span class="kw">let </span><span class="kw-2">mut </span>image = Image::new();
        <span class="kw">if </span><span class="self">self</span>.render_into(scaler, glyph_id, <span class="kw-2">&amp;mut </span>image) {
            <span class="prelude-val">Some</span>(image)
        } <span class="kw">else </span>{
            <span class="prelude-val">None
        </span>}
    }
}

<span class="kw">fn </span>fill_outline(
    outline: <span class="kw-2">&amp;mut </span>Outline,
    points: <span class="kw-2">&amp;</span>[glyf::Point],
    contours: <span class="kw-2">&amp;</span>[u16],
    tags: <span class="kw-2">&amp;</span>[u8],
    scaled: bool,
) -&gt; <span class="prelude-ty">Option</span>&lt;()&gt; {
    <span class="kw">use </span>glyf::Point <span class="kw">as </span>PointI;
    <span class="attribute">#[inline(always)]
    </span><span class="kw">fn </span>conv(p: glyf::Point, s: f32) -&gt; Point {
        Point::new(p.x <span class="kw">as </span>f32 * s, p.y <span class="kw">as </span>f32 * s)
    }
    <span class="kw">const </span>TAG_MASK: u8 = <span class="number">0x3</span>;
    <span class="kw">const </span>CONIC: u8 = <span class="number">0x0</span>;
    <span class="kw">const </span>ON: u8 = <span class="number">0x1</span>;
    <span class="kw">const </span>CUBIC: u8 = <span class="number">0x2</span>;
    <span class="kw">let </span>s = <span class="kw">if </span>scaled { <span class="number">1. </span>/ <span class="number">64. </span>} <span class="kw">else </span>{ <span class="number">1. </span>};
    <span class="kw">for </span>c <span class="kw">in </span><span class="number">0</span>..contours.len() {
        <span class="kw">let </span><span class="kw-2">mut </span>cur = <span class="kw">if </span>c &gt; <span class="number">0 </span>{
            contours[c - <span class="number">1</span>] <span class="kw">as </span>usize + <span class="number">1
        </span>} <span class="kw">else </span>{
            <span class="number">0
        </span>};
        <span class="kw">let </span><span class="kw-2">mut </span>last = contours[c] <span class="kw">as </span>usize;
        <span class="kw">if </span>last &lt; cur || last &gt;= points.len() {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span><span class="kw-2">mut </span>v_start = points[cur];
        <span class="kw">let </span>v_last = points[last];
        <span class="kw">let </span><span class="kw-2">mut </span>tag = tags[cur] &amp; TAG_MASK;
        <span class="kw">if </span>tag == CUBIC {
            <span class="kw">return </span><span class="prelude-val">None</span>;
        }
        <span class="kw">let </span><span class="kw-2">mut </span>step_point = <span class="bool-val">true</span>;
        <span class="kw">if </span>tag == CONIC {
            <span class="kw">if </span>tags[last] &amp; TAG_MASK == ON {
                v_start = v_last;
                last -= <span class="number">1</span>;
            } <span class="kw">else </span>{
                v_start.x = (v_start.x + v_last.x) / <span class="number">2</span>;
                v_start.y = (v_start.y + v_last.y) / <span class="number">2</span>;
            }
            step_point = <span class="bool-val">false</span>;
        }
        outline.move_to(conv(v_start, s));
        <span class="comment">// let mut do_close = true;
        </span><span class="kw">while </span>cur &lt; last {
            <span class="kw">if </span>step_point {
                cur += <span class="number">1</span>;
            }
            step_point = <span class="bool-val">true</span>;
            tag = tags[cur] &amp; TAG_MASK;
            <span class="kw">match </span>tag {
                ON =&gt; {
                    outline.line_to(conv(points[cur], s));
                    <span class="kw">continue</span>;
                }
                CONIC =&gt; {
                    <span class="kw">let </span><span class="kw-2">mut </span>do_close_conic = <span class="bool-val">true</span>;
                    <span class="kw">let </span><span class="kw-2">mut </span>v_control = points[cur];
                    <span class="kw">while </span>cur &lt; last {
                        cur += <span class="number">1</span>;
                        <span class="kw">let </span>point = points[cur];
                        tag = tags[cur] &amp; TAG_MASK;
                        <span class="kw">if </span>tag == ON {
                            outline.quad_to(conv(v_control, s), conv(point, s));
                            do_close_conic = <span class="bool-val">false</span>;
                            <span class="kw">break</span>;
                        }
                        <span class="kw">if </span>tag != CONIC {
                            <span class="kw">return </span><span class="prelude-val">None</span>;
                        }
                        <span class="kw">let </span>v_middle =
                            PointI::new((v_control.x + point.x) / <span class="number">2</span>, (v_control.y + point.y) / <span class="number">2</span>);
                        outline.quad_to(conv(v_control, s), conv(v_middle, s));
                        v_control = point;
                    }
                    <span class="kw">if </span>do_close_conic {
                        outline.quad_to(conv(v_control, s), conv(v_start, s));
                        <span class="comment">//                        do_close = false;
                        </span><span class="kw">break</span>;
                    }
                    <span class="kw">continue</span>;
                }
                <span class="kw">_ </span>=&gt; {
                    <span class="kw">if </span>cur + <span class="number">1 </span>&gt; last || (tags[cur + <span class="number">1</span>] &amp; TAG_MASK != CUBIC) {
                        <span class="kw">return </span><span class="prelude-val">None</span>;
                    }
                    <span class="kw">let </span>v1 = conv(points[cur], s);
                    <span class="kw">let </span>v2 = conv(points[cur + <span class="number">1</span>], s);
                    cur += <span class="number">2</span>;
                    <span class="kw">if </span>cur &lt;= last {
                        outline.curve_to(v1, v2, conv(points[cur], s));
                        <span class="kw">continue</span>;
                    }
                    outline.curve_to(v1, v2, conv(v_start, s));
                    <span class="comment">// do_close = false;
                    </span><span class="kw">break</span>;
                }
            }
        }
        <span class="kw">if </span><span class="bool-val">true </span>{
            outline.maybe_close();
        }
    }
    <span class="prelude-val">Some</span>(())
}

<span class="kw">struct </span>CffBuilder&lt;<span class="lifetime">&#39;a</span>&gt; {
    outline: <span class="kw-2">&amp;</span><span class="lifetime">&#39;a </span><span class="kw-2">mut </span>Outline,
}

<span class="kw">impl </span>cff::GlyphSink <span class="kw">for </span>CffBuilder&lt;<span class="lifetime">&#39;_</span>&gt; {
    <span class="kw">fn </span>move_to(<span class="kw-2">&amp;mut </span><span class="self">self</span>, x: f32, y: f32) {
        <span class="self">self</span>.outline.move_to(Point::new(x, y));
    }

    <span class="kw">fn </span>line_to(<span class="kw-2">&amp;mut </span><span class="self">self</span>, x: f32, y: f32) {
        <span class="self">self</span>.outline.line_to(Point::new(x, y));
    }

    <span class="kw">fn </span>curve_to(<span class="kw-2">&amp;mut </span><span class="self">self</span>, cx1: f32, cy1: f32, cx2: f32, cy2: f32, x: f32, y: f32) {
        <span class="self">self</span>.outline
            .curve_to(Point::new(cx1, cy1), Point::new(cx2, cy2), Point::new(x, y));
    }

    <span class="kw">fn </span>close(<span class="kw-2">&amp;mut </span><span class="self">self</span>) {
        <span class="self">self</span>.outline.close();
    }
}
</code></pre></div>
</section></div></main><div id="rustdoc-vars" data-root-path="../../../" data-current-crate="swash" data-themes="ayu,dark,light" data-resource-suffix="" data-rustdoc-version="1.65.0 (897e37553 2022-11-02)" ></div></body></html>